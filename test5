import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class ApiResponse<T> {
    private T data;
    private String status;
    private String statusMessage;
}




import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/api")
public class HelloController {

    @GetMapping("/hello")
    public ApiResponse<String> hello() {
        return new ApiResponse<>("Hello, World!", "SUCCESS", "Request was successful");
    }
}





import org.apache.ibatis.annotations.Mapper;
import org.apache.ibatis.annotations.Param;

import java.util.List;
import java.util.Map;

@Mapper
public interface UserMapper {
    void insertUsers(@Param("users") List<Map<String, String>> users);
}

<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">

<mapper namespace="com.example.demo.mapper.UserMapper">
    <insert id="insertUsers">
        INSERT INTO users (username, email)
        VALUES
        <foreach collection="users" item="user" separator=",">
            (#{user.name}, #{user.mail})
        </foreach>
    </insert>
</mapper>


import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.Map;

@Service
public class UserService {

    @Autowired
    private UserMapper userMapper;

    @Transactional
    public void insertUsers(List<Map<String, String>> users) {
        userMapper.insertUsers(users);
    }
}

















import React, { useEffect } from 'react';
import { useForm } from 'react-hook-form';
import FileDropComponent from './FileDropComponent';

const App = () => {
    const { register, handleSubmit, watch } = useForm();
    const selectedFile = watch('file');

    useEffect(() => {
        if (selectedFile && selectedFile.length > 0) {
            const file = selectedFile[0];
            const acceptedTypes = ['application/vnd.ms-excel', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet', 'text/csv'];
            if (file && acceptedTypes.includes(file.type)) {
                handleFileUpload(file);
            } else {
                alert('Only .xls, .xlsx, .csv files are accepted.');
            }
        }
    }, [selectedFile]);

    const handleFileUpload = async (file) => {
        const formData = new FormData();
        formData.append('file', file);

        try {
            const response = await fetch('/api/upload', {
                method: 'POST',
                body: formData,
            });

            if (response.ok) {
                const result = await response.json();
                console.log('File uploaded successfully:', result);
            } else {
                console.error('File upload failed');
            }
        } catch (error) {
            console.error('Error uploading file:', error);
        }
    };

    const onSubmit = (data) => {
        console.log('Form Data:', data);
    };

    return (
        <form onSubmit={handleSubmit(onSubmit)}>
            <FileDropComponent register={register} />
            <button type="submit">Submit</button>
        </form>
    );
};

export default App;






import React, { useState, useRef } from 'react';

const FileDropComponent = ({ register }) => {
    const [isDragging, setIsDragging] = useState(false);
    const fileInputRef = useRef(null);

    const handleDragEnter = (e) => {
        e.preventDefault();
        e.stopPropagation();
        setIsDragging(true);
    };

    const handleDragLeave = (e) => {
        e.preventDefault();
        e.stopPropagation();
        setIsDragging(false);
    };

    const handleDragOver = (e) => {
        e.preventDefault();
        e.stopPropagation();
    };

    const handleDrop = (e) => {
        e.preventDefault();
        e.stopPropagation();
        setIsDragging(false);

        if (e.dataTransfer && e.dataTransfer.files) {
            const droppedFiles = Array.from(e.dataTransfer.files);
            const acceptedTypes = ['application/vnd.ms-excel', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet', 'text/csv'];

            if (droppedFiles.length > 1) {
                alert('Only one file is allowed.');
                return;
            }

            const file = droppedFiles.find(file => acceptedTypes.includes(file.type));

            if (file) {
                const dataTransfer = new DataTransfer();
                dataTransfer.items.add(file);
                fileInputRef.current.files = dataTransfer.files;
            } else {
                alert('Only .xls, .xlsx, .csv files are accepted.');
            }
        }
    };

    const handleFileChange = (e) => {
        const file = e.target.files[0];
        const acceptedTypes = ['application/vnd.ms-excel', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet', 'text/csv'];
        if (file && acceptedTypes.includes(file.type)) {
            const dataTransfer = new DataTransfer();
            dataTransfer.items.add(file);
            fileInputRef.current.files = dataTransfer.files;
        } else {
            alert('Only .xls, .xlsx, .csv files are accepted.');
        }
    };

    const handleDivClick = () => {
        if (fileInputRef.current) {
            fileInputRef.current.click();
        } else {
            console.error('File input ref is not assigned');
        }
    };

    return (
        <div
            onDragEnter={handleDragEnter}
            onDragLeave={handleDragLeave}
            onDragOver={handleDragOver}
            onDrop={handleDrop}
            onClick={handleDivClick}
            style={{
                border: '2px dashed #cccccc',
                borderRadius: '4px',
                padding: '20px',
                textAlign: 'center',
                backgroundColor: isDragging ? '#e9e9e9' : '#ffffff',
                cursor: 'pointer'
            }}
        >
            <input
                type="file"
                style={{ display: 'none' }}
                {...register('file', {
                    required: 'A file is required'
                })}
                ref={fileInputRef}
                onChange={handleFileChange}
            />
            <p>{isDragging ? 'Drop the file here...' : 'Drag & drop a file here, or click to select a file'}</p>
        </div>
    );
};

export default FileDropComponent;






















import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class HashMapListExample {
    public static void main(String[] args) {
        // HashMap 객체들을 저장할 ArrayList 생성
        List<Map<String, Object>> hashMapList = new ArrayList<>();

        // 예제 데이터 (이 부분은 실제 사용 사례에 따라 달라질 수 있음)
        String[] names = {"Alice", "Bob", "Charlie"};
        int[] ages = {25, 30, 35};

        // for문을 사용하여 각 HashMap을 생성하고 리스트에 추가
        for (int i = 0; i < names.length; i++) {
            Map<String, Object> personMap = new HashMap<>();
            personMap.put("name", names[i]);
            personMap.put("age", ages[i]);

            // 생성된 HashMap을 리스트에 추가
            hashMapList.add(personMap);
        }

        // 리스트와 그 내용 출력
        System.out.println(hashMapList);
        for (Map<String, Object> person : hashMapList) {
            System.out.println("Name: " + person.get("name") + ", Age: " + person.get("age"));
        }
    }
}









import React, { useState } from 'react';

const FileDropComponent = ({ register }) => {
    const [isDragging, setIsDragging] = useState(false);
    const [file, setFile] = useState(null);

    const handleDragEnter = (e) => {
        e.preventDefault();
        e.stopPropagation();
        setIsDragging(true);
    };

    const handleDragLeave = (e) => {
        e.preventDefault();
        e.stopPropagation();
        setIsDragging(false);
    };

    const handleDragOver = (e) => {
        e.preventDefault();
        e.stopPropagation();
    };

    const handleDrop = (e) => {
        e.preventDefault();
        e.stopPropagation();
        setIsDragging(false);

        const droppedFiles = Array.from(e.dataTransfer.files);
        const acceptedTypes = ['application/vnd.ms-excel', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet', 'text/csv'];

        if (droppedFiles.length > 1) {
            alert('Only one file is allowed.');
            return;
        }

        const file = droppedFiles.find(file => acceptedTypes.includes(file.type));

        if (file) {
            setFile(file);
            handleFileUpload(file);
        } else {
            alert('Only .xls, .xlsx, .csv files are accepted.');
        }
    };

    const handleFileUpload = async (file) => {
        const formData = new FormData();
        formData.append('file', file);

        try {
            const response = await fetch('/api/upload', {
                method: 'POST',
                body: formData,
            });

            if (response.ok) {
                const result = await response.json();
                console.log('File uploaded successfully:', result);
            } else {
                console.error('File upload failed');
            }
        } catch (error) {
            console.error('Error uploading file:', error);
        }
    };

    const handleFileChange = (e) => {
        const file = e.target.files[0];
        const acceptedTypes = ['application/vnd.ms-excel', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet', 'text/csv'];
        if (file && acceptedTypes.includes(file.type)) {
            setFile(file);
            handleFileUpload(file);
        } else {
            alert('Only .xls, .xlsx, .csv files are accepted.');
        }
    };

    return (
        <div
            onDragEnter={handleDragEnter}
            onDragLeave={handleDragLeave}
            onDragOver={handleDragOver}
            onDrop={handleDrop}
            style={{
                border: '2px dashed #cccccc',
                borderRadius: '4px',
                padding: '20px',
                textAlign: 'center',
                backgroundColor: isDragging ? '#e9e9e9' : '#ffffff',
                cursor: 'pointer'
            }}
        >
            <input
                type="file"
                style={{ display: 'none' }}
                {...register('file', {
                    required: 'A file is required'
                })}
                onChange={handleFileChange}
            />
            <p>{isDragging ? 'Drop the file here...' : 'Drag & drop a file here, or click to select a file'}</p>
            {file && <p>Selected file: {file.name}</p>}
        </div>
    );
};

export default FileDropComponent;








import React, { useState } from 'react';

const FileDropComponent = ({ register, onFileSelect }) => {
    const [isDragging, setIsDragging] = useState(false);

    const handleDragEnter = (e) => {
        e.preventDefault();
        e.stopPropagation();
        setIsDragging(true);
    };

    const handleDragLeave = (e) => {
        e.preventDefault();
        e.stopPropagation();
        setIsDragging(false);
    };

    const handleDragOver = (e) => {
        e.preventDefault();
        e.stopPropagation();
    };

    const handleDrop = (e) => {
        e.preventDefault();
        e.stopPropagation();
        setIsDragging(false);

        const droppedFiles = Array.from(e.dataTransfer.files);
        const acceptedTypes = ['application/vnd.ms-excel', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet', 'text/csv'];

        if (droppedFiles.length > 1) {
            alert('Only one file is allowed.');
            return;
        }

        const file = droppedFiles.find(file => acceptedTypes.includes(file.type));

        if (file) {
            onFileSelect(file);
        } else {
            alert('Only .xls, .xlsx, .csv files are accepted.');
        }
    };

    const handleFileChange = (e) => {
        const file = e.target.files[0];
        const acceptedTypes = ['application/vnd.ms-excel', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet', 'text/csv'];
        if (file && acceptedTypes.includes(file.type)) {
            onFileSelect(file);
        } else {
            alert('Only .xls, .xlsx, .csv files are accepted.');
        }
    };

    return (
        <div
            onDragEnter={handleDragEnter}
            onDragLeave={handleDragLeave}
            onDragOver={handleDragOver}
            onDrop={handleDrop}
            style={{
                border: '2px dashed #cccccc',
                borderRadius: '4px',
                padding: '20px',
                textAlign: 'center',
                backgroundColor: isDragging ? '#e9e9e9' : '#ffffff',
                cursor: 'pointer'
            }}
        >
            <input
                type="file"
                style={{ display: 'none' }}
                {...register('file', {
                    required: 'A file is required'
                })}
                onChange={handleFileChange}
            />
            <p>{isDragging ? 'Drop the file here...' : 'Drag & drop a file here, or click to select a file'}</p>
        </div>
    );
};

export default FileDropComponent;








<configuration>
    <property name="LOG_PATH" value="logs" />
    <property name="LOG_FILE" value="${LOG_PATH}/application.log" />

    <!-- 콘솔 출력 설정 -->
    <appender name="Console" class="ch.qos.logback.core.ConsoleAppender">
        <encoder>
            <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n</pattern>
        </encoder>
    </appender>

    <!-- 파일 출력 설정 -->
    <appender name="File" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <file>${LOG_FILE}</file>
        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <!-- 로그 파일 롤링 설정 (일별 롤링) -->
            <fileNamePattern>${LOG_PATH}/application.%d{yyyy-MM-dd}.log</fileNamePattern>
            <maxHistory>30</maxHistory>
        </rollingPolicy>
        <encoder>
            <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n</pattern>
        </encoder>
    </appender>

    <root level="info">
        <appender-ref ref="Console" />
        <appender-ref ref="File" />
    </root>
</configuration>