import org.apache.ibatis.session.SqlSessionFactory;
import org.mybatis.spring.SqlSessionFactoryBean;
import org.mybatis.spring.annotation.MapperScan;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.core.io.support.PathMatchingResourcePatternResolver;

import javax.sql.DataSource;

@Configuration
@MapperScan("com.example.demo.mapper")
public class MyBatisConfig {

    @Bean
    public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
        SqlSessionFactoryBean sessionFactory = new SqlSessionFactoryBean();
        sessionFactory.setDataSource(dataSource);
        sessionFactory.setMapperLocations(
                new PathMatchingResourcePatternResolver().getResources("classpath:mapper/*.xml"));
        return sessionFactory.getObject();
    }
}



import org.apache.ibatis.annotations.Mapper;
import org.apache.ibatis.annotations.Param;
import com.example.demo.FileStatus;

@Mapper
public interface FileStatusMapper {
    void insertFileStatus(@Param("fileStatus") FileStatus fileStatus);

    FileStatus getFileStatusById(@Param("id") Long id);

    void updateFileStatus(@Param("fileStatus") FileStatus fileStatus);

    void deleteFileStatus(@Param("id") Long id);
}












import React, { useState, useEffect } from 'react';
import axios from 'axios';

const FileUpload = () => {
    const [selectedFile, setSelectedFile] = useState(null);
    const [uploadStatus, setUploadStatus] = useState('');
    const [downloadUrl, setDownloadUrl] = useState('');
    const [fileId, setFileId] = useState(null);

    const onFileChange = (event) => {
        setSelectedFile(event.target.files[0]);
    };

    const onFileUpload = async () => {
        const formData = new FormData();
        formData.append('file', selectedFile);

        try {
            const response = await axios.post('/api/upload', formData, {
                headers: {
                    'Content-Type': 'multipart/form-data'
                }
            });
            setUploadStatus('File uploaded successfully!');
            setFileId(response.data.id); // Assuming the backend returns the file ID
        } catch (error) {
            console.error('Error uploading file:', error);
            setUploadStatus('Error uploading file.');
        }
    };

    useEffect(() => {
        let interval;
        if (fileId) {
            interval = setInterval(async () => {
                try {
                    const response = await axios.get(`/api/status/${fileId}`);
                    if (response.data.status === 'COMPLETED') {
                        clearInterval(interval);
                        setDownloadUrl(`/api/download/${fileId}`);
                        setUploadStatus('File processing completed. You can download the file now.');
                    }
                } catch (error) {
                    console.error('Error checking status:', error);
                    setUploadStatus('Error checking status.');
                }
            }, 15000); // 15 seconds
        }
        return () => clearInterval(interval);
    }, [fileId]);

    return (
        <div>
            <h2>File Upload</h2>
            <input type="file" onChange={onFileChange} />
            <button onClick={onFileUpload}>Upload</button>
            <p>{uploadStatus}</p>
            {downloadUrl && <a href={downloadUrl} download>Download File</a>}
        </div>
    );
};

export default FileUpload;






import React, { useState } from 'react';
import axios from 'axios';

const FileUpload = () => {
    const [selectedFile, setSelectedFile] = useState(null);
    const [uploadStatus, setUploadStatus] = useState('');
    const [downloadUrl, setDownloadUrl] = useState('');

    const onFileChange = (event) => {
        setSelectedFile(event.target.files[0]);
    };

    const onFileUpload = async () => {
        const formData = new FormData();
        formData.append('file', selectedFile);

        try {
            const response = await axios.post('/api/upload', formData, {
                headers: {
                    'Content-Type': 'multipart/form-data'
                }
            });
            setUploadStatus('File uploaded successfully!');
            checkStatus(response.data.fileId);
        } catch (error) {
            console.error('Error uploading file:', error);
            setUploadStatus('Error uploading file.');
        }
    };

    const checkStatus = (fileId) => {
        const interval = setInterval(async () => {
            try {
                const response = await axios.get(`/api/status/${fileId}`);
                if (response.data.status === 'COMPLETED') {
                    clearInterval(interval);
                    setDownloadUrl(`/api/download/${fileId}`);
                    setUploadStatus('File processing completed. You can download the file now.');
                }
            } catch (error) {
                console.error('Error checking status:', error);
                setUploadStatus('Error checking status.');
            }
        }, 15000); // 15 seconds
    };

    return (
        <div>
            <h2>File Upload</h2>
            <input type="file" onChange={onFileChange} />
            <button onClick={onFileUpload}>Upload</button>
            <p>{uploadStatus}</p>
            {downloadUrl && <a href={downloadUrl} download>Download File</a>}
        </div>
    );
};

export default FileUpload;





plugins {
    id 'org.springframework.boot' version '2.7.2'
    id 'io.spring.dependency-management' version '1.0.11.RELEASE'
    id 'java'
}

group = 'com.example'
version = '0.0.1-SNAPSHOT'
sourceCompatibility = '11'

repositories {
    mavenCentral()
}

dependencies {
    implementation 'org.springframework.boot:spring-boot-starter'
    implementation 'org.springframework.boot:spring-boot-starter-web'
    implementation 'org.mybatis.spring.boot:mybatis-spring-boot-starter:2.1.4'
    runtimeOnly 'com.h2database:h2'

    testImplementation 'org.springframework.boot:spring-boot-starter-test'
}

test {
    useJUnitPlatform()
}





spring:
  datasource:
    url: jdbc:h2:mem:testdb
    driver-class-name: org.h2.Driver
    username: sa
    password:
  h2:
    console:
      enabled: true
  mybatis:
    mapper-locations: classpath:mappers/*.xml






public class User {
    private int id;
    private String name;
    private String email;

    // Getters and Setters
}






import org.apache.ibatis.annotations.*;

import java.util.List;

@Mapper
public interface UserMapper {

    @Insert("INSERT INTO users (name, email) VALUES (#{name}, #{email})")
    @Options(useGeneratedKeys = true, keyProperty = "id")
    void insertUser(User user);

    @Select("SELECT * FROM users WHERE id = #{id}")
    User getUserById(int id);

    @Select("SELECT * FROM users")
    List<User> getAllUsers();

    @Update("UPDATE users SET name = #{name}, email = #{email} WHERE id = #{id}")
    void updateUser(User user);

    @Delete("DELETE FROM users WHERE id = #{id}")
    void deleteUser(int id);
}






<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">

<mapper namespace="com.example.demo.mapper.UserMapper">
    <resultMap id="userResultMap" type="User">
        <id property="id" column="id" />
        <result property="name" column="name" />
        <result property="email" column="email" />
    </resultMap>

    <sql id="userColumns">id, name, email</sql>

    <insert id="insertUser" parameterType="User" useGeneratedKeys="true" keyProperty="id">
        INSERT INTO users (name, email)
        VALUES (#{name}, #{email})
    </insert>

    <select id="getUserById" parameterType="int" resultMap="userResultMap">
        SELECT <include refid="userColumns" />
        FROM users
        WHERE id = #{id}
    </select>

    <select id="getAllUsers" resultMap="userResultMap">
        SELECT <include refid="userColumns" />
        FROM users
    </select>

    <update id="updateUser" parameterType="User">
        UPDATE users
        SET name = #{name}, email = #{email}
        WHERE id = #{id}
    </update>

    <delete id="deleteUser" parameterType="int">
        DELETE FROM users
        WHERE id = #{id}
    </delete>
</mapper>



CREATE TABLE users (
    id INT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(255) NOT NULL,
    email VARCHAR(255) NOT NULL
);




import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.List;

@Service
public class UserService {

    @Autowired
    private UserMapper userMapper;

    public void insertUser(User user) {
        userMapper.insertUser(user);
    }

    public User getUserById(int id) {
        return userMapper.getUserById(id);
    }

    public List<User> getAllUsers() {
        return userMapper.getAllUsers();
    }

    public void updateUser(User user) {
        userMapper.updateUser(user);
    }

    public void deleteUser(int id) {
        userMapper.deleteUser(id);
    }
}




import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/users")
public class UserController {

    @Autowired
    private UserService userService;

    @PostMapping
    public String createUser(@RequestBody User user) {
        userService.insertUser(user);
        return "User created successfully!";
    }

    @GetMapping("/{id}")
    public User getUserById(@PathVariable int id) {
        return userService.getUserById(id);
    }

    @GetMapping
    public List<User> getAllUsers() {
        return userService.getAllUsers();
    }

    @PutMapping("/{id}")
    public String updateUser(@PathVariable int id, @RequestBody User user) {
        user.setId(id);
        userService.updateUser(user);
        return "User updated successfully!";
    }

    @DeleteMapping("/{id}")
    public String deleteUser(@PathVariable int id) {
        userService.deleteUser(id);
        return "User deleted successfully!";
    }
}


















import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class ApiResponse<T> {
    private T data;
    private String status;
    private String statusMessage;
}




import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/api")
public class HelloController {

    @GetMapping("/hello")
    public ApiResponse<String> hello() {
        return new ApiResponse<>("Hello, World!", "SUCCESS", "Request was successful");
    }
}





import org.apache.ibatis.annotations.Mapper;
import org.apache.ibatis.annotations.Param;

import java.util.List;
import java.util.Map;

@Mapper
public interface UserMapper {
    void insertUsers(@Param("users") List<Map<String, String>> users);
}

<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">

<mapper namespace="com.example.demo.mapper.UserMapper">
    <insert id="insertUsers">
        INSERT INTO users (username, email)
        VALUES
        <foreach collection="users" item="user" separator=",">
            (#{user.name}, #{user.mail})
        </foreach>
    </insert>
</mapper>


import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.Map;

@Service
public class UserService {

    @Autowired
    private UserMapper userMapper;

    @Transactional
    public void insertUsers(List<Map<String, String>> users) {
        userMapper.insertUsers(users);
    }
}

















import React, { useEffect } from 'react';
import { useForm } from 'react-hook-form';
import FileDropComponent from './FileDropComponent';

const App = () => {
    const { register, handleSubmit, watch } = useForm();
    const selectedFile = watch('file');

    useEffect(() => {
        if (selectedFile && selectedFile.length > 0) {
            const file = selectedFile[0];
            const acceptedTypes = ['application/vnd.ms-excel', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet', 'text/csv'];
            if (file && acceptedTypes.includes(file.type)) {
                handleFileUpload(file);
            } else {
                alert('Only .xls, .xlsx, .csv files are accepted.');
            }
        }
    }, [selectedFile]);

    const handleFileUpload = async (file) => {
        const formData = new FormData();
        formData.append('file', file);

        try {
            const response = await fetch('/api/upload', {
                method: 'POST',
                body: formData,
            });

            if (response.ok) {
                const result = await response.json();
                console.log('File uploaded successfully:', result);
            } else {
                console.error('File upload failed');
            }
        } catch (error) {
            console.error('Error uploading file:', error);
        }
    };

    const onSubmit = (data) => {
        console.log('Form Data:', data);
    };

    return (
        <form onSubmit={handleSubmit(onSubmit)}>
            <FileDropComponent register={register} />
            <button type="submit">Submit</button>
        </form>
    );
};

export default App;






import React, { useState, useRef } from 'react';

const FileDropComponent = ({ register }) => {
    const [isDragging, setIsDragging] = useState(false);
    const fileInputRef = useRef(null);

    const handleDragEnter = (e) => {
        e.preventDefault();
        e.stopPropagation();
        setIsDragging(true);
    };

    const handleDragLeave = (e) => {
        e.preventDefault();
        e.stopPropagation();
        setIsDragging(false);
    };

    const handleDragOver = (e) => {
        e.preventDefault();
        e.stopPropagation();
    };

    const handleDrop = (e) => {
        e.preventDefault();
        e.stopPropagation();
        setIsDragging(false);

        if (e.dataTransfer && e.dataTransfer.files) {
            const droppedFiles = Array.from(e.dataTransfer.files);
            const acceptedTypes = ['application/vnd.ms-excel', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet', 'text/csv'];

            if (droppedFiles.length > 1) {
                alert('Only one file is allowed.');
                return;
            }

            const file = droppedFiles.find(file => acceptedTypes.includes(file.type));

            if (file) {
                const dataTransfer = new DataTransfer();
                dataTransfer.items.add(file);
                fileInputRef.current.files = dataTransfer.files;
            } else {
                alert('Only .xls, .xlsx, .csv files are accepted.');
            }
        }
    };

    const handleFileChange = (e) => {
        const file = e.target.files[0];
        const acceptedTypes = ['application/vnd.ms-excel', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet', 'text/csv'];
        if (file && acceptedTypes.includes(file.type)) {
            const dataTransfer = new DataTransfer();
            dataTransfer.items.add(file);
            fileInputRef.current.files = dataTransfer.files;
        } else {
            alert('Only .xls, .xlsx, .csv files are accepted.');
        }
    };

    const handleDivClick = () => {
        if (fileInputRef.current) {
            fileInputRef.current.click();
        } else {
            console.error('File input ref is not assigned');
        }
    };

    return (
        <div
            onDragEnter={handleDragEnter}
            onDragLeave={handleDragLeave}
            onDragOver={handleDragOver}
            onDrop={handleDrop}
            onClick={handleDivClick}
            style={{
                border: '2px dashed #cccccc',
                borderRadius: '4px',
                padding: '20px',
                textAlign: 'center',
                backgroundColor: isDragging ? '#e9e9e9' : '#ffffff',
                cursor: 'pointer'
            }}
        >
            <input
                type="file"
                style={{ display: 'none' }}
                {...register('file', {
                    required: 'A file is required'
                })}
                ref={fileInputRef}
                onChange={handleFileChange}
            />
            <p>{isDragging ? 'Drop the file here...' : 'Drag & drop a file here, or click to select a file'}</p>
        </div>
    );
};

export default FileDropComponent;






















import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class HashMapListExample {
    public static void main(String[] args) {
        // HashMap 객체들을 저장할 ArrayList 생성
        List<Map<String, Object>> hashMapList = new ArrayList<>();

        // 예제 데이터 (이 부분은 실제 사용 사례에 따라 달라질 수 있음)
        String[] names = {"Alice", "Bob", "Charlie"};
        int[] ages = {25, 30, 35};

        // for문을 사용하여 각 HashMap을 생성하고 리스트에 추가
        for (int i = 0; i < names.length; i++) {
            Map<String, Object> personMap = new HashMap<>();
            personMap.put("name", names[i]);
            personMap.put("age", ages[i]);

            // 생성된 HashMap을 리스트에 추가
            hashMapList.add(personMap);
        }

        // 리스트와 그 내용 출력
        System.out.println(hashMapList);
        for (Map<String, Object> person : hashMapList) {
            System.out.println("Name: " + person.get("name") + ", Age: " + person.get("age"));
        }
    }
}









import React, { useState } from 'react';

const FileDropComponent = ({ register }) => {
    const [isDragging, setIsDragging] = useState(false);
    const [file, setFile] = useState(null);

    const handleDragEnter = (e) => {
        e.preventDefault();
        e.stopPropagation();
        setIsDragging(true);
    };

    const handleDragLeave = (e) => {
        e.preventDefault();
        e.stopPropagation();
        setIsDragging(false);
    };

    const handleDragOver = (e) => {
        e.preventDefault();
        e.stopPropagation();
    };

    const handleDrop = (e) => {
        e.preventDefault();
        e.stopPropagation();
        setIsDragging(false);

        const droppedFiles = Array.from(e.dataTransfer.files);
        const acceptedTypes = ['application/vnd.ms-excel', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet', 'text/csv'];

        if (droppedFiles.length > 1) {
            alert('Only one file is allowed.');
            return;
        }

        const file = droppedFiles.find(file => acceptedTypes.includes(file.type));

        if (file) {
            setFile(file);
            handleFileUpload(file);
        } else {
            alert('Only .xls, .xlsx, .csv files are accepted.');
        }
    };

    const handleFileUpload = async (file) => {
        const formData = new FormData();
        formData.append('file', file);

        try {
            const response = await fetch('/api/upload', {
                method: 'POST',
                body: formData,
            });

            if (response.ok) {
                const result = await response.json();
                console.log('File uploaded successfully:', result);
            } else {
                console.error('File upload failed');
            }
        } catch (error) {
            console.error('Error uploading file:', error);
        }
    };

    const handleFileChange = (e) => {
        const file = e.target.files[0];
        const acceptedTypes = ['application/vnd.ms-excel', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet', 'text/csv'];
        if (file && acceptedTypes.includes(file.type)) {
            setFile(file);
            handleFileUpload(file);
        } else {
            alert('Only .xls, .xlsx, .csv files are accepted.');
        }
    };

    return (
        <div
            onDragEnter={handleDragEnter}
            onDragLeave={handleDragLeave}
            onDragOver={handleDragOver}
            onDrop={handleDrop}
            style={{
                border: '2px dashed #cccccc',
                borderRadius: '4px',
                padding: '20px',
                textAlign: 'center',
                backgroundColor: isDragging ? '#e9e9e9' : '#ffffff',
                cursor: 'pointer'
            }}
        >
            <input
                type="file"
                style={{ display: 'none' }}
                {...register('file', {
                    required: 'A file is required'
                })}
                onChange={handleFileChange}
            />
            <p>{isDragging ? 'Drop the file here...' : 'Drag & drop a file here, or click to select a file'}</p>
            {file && <p>Selected file: {file.name}</p>}
        </div>
    );
};

export default FileDropComponent;








import React, { useState } from 'react';

const FileDropComponent = ({ register, onFileSelect }) => {
    const [isDragging, setIsDragging] = useState(false);

    const handleDragEnter = (e) => {
        e.preventDefault();
        e.stopPropagation();
        setIsDragging(true);
    };

    const handleDragLeave = (e) => {
        e.preventDefault();
        e.stopPropagation();
        setIsDragging(false);
    };

    const handleDragOver = (e) => {
        e.preventDefault();
        e.stopPropagation();
    };

    const handleDrop = (e) => {
        e.preventDefault();
        e.stopPropagation();
        setIsDragging(false);

        const droppedFiles = Array.from(e.dataTransfer.files);
        const acceptedTypes = ['application/vnd.ms-excel', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet', 'text/csv'];

        if (droppedFiles.length > 1) {
            alert('Only one file is allowed.');
            return;
        }

        const file = droppedFiles.find(file => acceptedTypes.includes(file.type));

        if (file) {
            onFileSelect(file);
        } else {
            alert('Only .xls, .xlsx, .csv files are accepted.');
        }
    };

    const handleFileChange = (e) => {
        const file = e.target.files[0];
        const acceptedTypes = ['application/vnd.ms-excel', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet', 'text/csv'];
        if (file && acceptedTypes.includes(file.type)) {
            onFileSelect(file);
        } else {
            alert('Only .xls, .xlsx, .csv files are accepted.');
        }
    };

    return (
        <div
            onDragEnter={handleDragEnter}
            onDragLeave={handleDragLeave}
            onDragOver={handleDragOver}
            onDrop={handleDrop}
            style={{
                border: '2px dashed #cccccc',
                borderRadius: '4px',
                padding: '20px',
                textAlign: 'center',
                backgroundColor: isDragging ? '#e9e9e9' : '#ffffff',
                cursor: 'pointer'
            }}
        >
            <input
                type="file"
                style={{ display: 'none' }}
                {...register('file', {
                    required: 'A file is required'
                })}
                onChange={handleFileChange}
            />
            <p>{isDragging ? 'Drop the file here...' : 'Drag & drop a file here, or click to select a file'}</p>
        </div>
    );
};

export default FileDropComponent;








<configuration>
    <property name="LOG_PATH" value="logs" />
    <property name="LOG_FILE" value="${LOG_PATH}/application.log" />

    <!-- 콘솔 출력 설정 -->
    <appender name="Console" class="ch.qos.logback.core.ConsoleAppender">
        <encoder>
            <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n</pattern>
        </encoder>
    </appender>

    <!-- 파일 출력 설정 -->
    <appender name="File" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <file>${LOG_FILE}</file>
        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <!-- 로그 파일 롤링 설정 (일별 롤링) -->
            <fileNamePattern>${LOG_PATH}/application.%d{yyyy-MM-dd}.log</fileNamePattern>
            <maxHistory>30</maxHistory>
        </rollingPolicy>
        <encoder>
            <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n</pattern>
        </encoder>
    </appender>

    <root level="info">
        <appender-ref ref="Console" />
        <appender-ref ref="File" />
    </root>
</configuration>