아래의 코드는 각 맵의 키를 컬럼명으로 사용하고, 값을 행으로 추가하는 방법을 보여줍니다. 기존 파일의 컬럼을 유지하면서 새로운 컬럼이 있으면 뒤에 추가됩니다.

### 엑셀 파일에 데이터 추가

#### ExcelUtils.java

```java
package com.example.demo.utils;

import org.apache.poi.ss.usermodel.*;
import org.apache.poi.xssf.usermodel.XSSFSheet;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;

import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.*;

public class ExcelUtils {

    public static void writeDataToExcel(List<Map<String, String>> data, String filePath) throws IOException {
        XSSFWorkbook workbook;
        XSSFSheet sheet;
        boolean fileExists = new java.io.File(filePath).exists();
        Set<String> existingHeaders = new LinkedHashSet<>();
        int rowIndex = 0;

        if (fileExists) {
            try (FileInputStream fileIn = new FileInputStream(filePath)) {
                workbook = new XSSFWorkbook(fileIn);
                sheet = workbook.getSheetAt(0);
                rowIndex = sheet.getLastRowNum() + 1;

                // Read existing headers
                Row headerRow = sheet.getRow(0);
                for (Cell cell : headerRow) {
                    existingHeaders.add(cell.getStringCellValue());
                }
            }
        } else {
            workbook = new XSSFWorkbook();
            sheet = workbook.createSheet("Data");
            rowIndex = 1; // Start writing data from the second row (first row is header)
        }

        // Determine all headers (existing + new)
        Set<String> allHeaders = new LinkedHashSet<>(existingHeaders);
        for (Map<String, String> rowMap : data) {
            allHeaders.addAll(rowMap.keySet());
        }

        // Write headers if the file did not exist
        if (!fileExists) {
            Row headerRow = sheet.createRow(0);
            int headerCellIndex = 0;
            for (String header : allHeaders) {
                Cell cell = headerRow.createCell(headerCellIndex++);
                cell.setCellValue(header);
            }
        } else {
            // Update headers if there are new headers
            Row headerRow = sheet.getRow(0);
            int headerCellIndex = headerRow.getLastCellNum();
            for (String header : allHeaders) {
                if (!existingHeaders.contains(header)) {
                    Cell cell = headerRow.createCell(headerCellIndex++);
                    cell.setCellValue(header);
                }
            }
        }

        // Write data rows
        for (Map<String, String> rowMap : data) {
            Row row = sheet.createRow(rowIndex++);
            int cellIndex = 0;
            for (String header : allHeaders) {
                Cell cell = row.createCell(cellIndex++);
                cell.setCellValue(rowMap.getOrDefault(header, ""));
            }
        }

        // Write to file
        try (FileOutputStream fileOut = new FileOutputStream(filePath)) {
            workbook.write(fileOut);
        }
        workbook.close();
    }
}
```

### CSV 파일에 데이터 추가

#### CSVUtils.java

```java
package com.example.demo.utils;

import com.opencsv.CSVReader;
import com.opencsv.CSVWriter;

import java.io.*;
import java.util.*;

public class CSVUtils {

    public static void writeDataToCSV(List<Map<String, String>> data, String filePath) throws IOException {
        boolean fileExists = new java.io.File(filePath).exists();
        List<String[]> existingData = new ArrayList<>();
        Set<String> existingHeaders = new LinkedHashSet<>();
        Set<String> allHeaders = new LinkedHashSet<>();

        // Read existing data and headers if file exists
        if (fileExists) {
            try (CSVReader reader = new CSVReader(new FileReader(filePath))) {
                String[] line;
                while ((line = reader.readNext()) != null) {
                    existingData.add(line);
                }
            }
            if (!existingData.isEmpty()) {
                existingHeaders.addAll(Arrays.asList(existingData.get(0)));
            }
        }

        // Determine all headers (existing + new)
        for (Map<String, String> rowMap : data) {
            allHeaders.addAll(rowMap.keySet());
        }
        allHeaders.addAll(existingHeaders);

        // Write data to CSV
        try (CSVWriter writer = new CSVWriter(new FileWriter(filePath))) {
            // Write headers
            writer.writeNext(allHeaders.toArray(new String[0]));

            // Write existing data with new headers
            if (fileExists && !existingData.isEmpty()) {
                for (int i = 1; i < existingData.size(); i++) {
                    String[] oldRow = existingData.get(i);
                    String[] newRow = new String[allHeaders.size()];
                    Map<String, Integer> headerIndexMap = getHeaderIndexMap(existingHeaders);
                    int newIndex = 0;
                    for (String header : allHeaders) {
                        if (headerIndexMap.containsKey(header)) {
                            newRow[newIndex++] = oldRow[headerIndexMap.get(header)];
                        } else {
                            newRow[newIndex++] = "";
                        }
                    }
                    writer.writeNext(newRow);
                }
            }

            // Write new data
            for (Map<String, String> rowMap : data) {
                String[] row = new String[allHeaders.size()];
                int cellIndex = 0;
                for (String header : allHeaders) {
                    row[cellIndex++] = rowMap.getOrDefault(header, "");
                }
                writer.writeNext(row);
            }
        }
    }

    private static Map<String, Integer> getHeaderIndexMap(Set<String> headers) {
        Map<String, Integer> headerIndexMap = new HashMap<>();
        int index = 0;
        for (String header : headers) {
            headerIndexMap.put(header, index++);
        }
        return headerIndexMap;
    }
}
```

### 사용 예제

#### 엑셀 파일에 데이터 추가

```java
List<Map<String, String>> data = List.of(
    Map.of("name", "antony"),
    Map.of("mail", "antony@naver.com"),
    Map.of("name", "lim"),
    Map.of("mail", "lim@naver.com")
);

String excelFilePath = "data.xlsx";
ExcelUtils.writeDataToExcel(data, excelFilePath);
```

#### CSV 파일에 데이터 추가

```java
List<Map<String, String>> data = List.of(
    Map.of("name", "antony"),
    Map.of("mail", "antony@naver.com"),
    Map.of("name", "lim"),
    Map.of("mail", "lim@naver.com")
);

String csvFilePath = "data.csv";
CSVUtils.writeDataToCSV(data, csvFilePath);







두 단계로 감싸져 있는 경우, MyBatis 매핑 파일에서 내부 객체의 필드를 적절히 매핑해야 합니다. 예를 들어, `FileStatus` 클래스의 `status` 필드가 `Status`라는 객체로 감싸져 있는 경우를 다루겠습니다.

### 1. Java 객체 클래스 정의

#### Status.java

```java
package com.example.demo;

public class Status {
    private String status;

    // Getters and Setters
    public String getStatus() {
        return status;
    }

    public void setStatus(String status) {
        this.status = status;
    }
}
```

#### FileStatus.java

```java
package com.example.demo;

public class FileStatus {
    private UUIDWrapper id;
    private Status status;
    private String fileName;

    // Getters and Setters
    public UUIDWrapper getId() {
        return id;
    }

    public void setId(UUIDWrapper id) {
        this.id = id;
    }

    public Status getStatus() {
        return status;
    }

    public void setStatus(Status status) {
        this.status = status;
    }

    public String getFileName() {
        return fileName;
    }

    public void setFileName(String fileName) {
        this.fileName = fileName;
    }
}
```

### 2. MyBatis 매퍼 XML 파일 정의

MyBatis 매핑 파일에서 내부 객체를 매핑하기 위해 `association` 요소를 사용합니다.

#### src/main/resources/mapper/FileStatusMapper.xml

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">

<mapper namespace="com.example.demo.mapper.FileStatusMapper">
    <resultMap id="fileStatusResultMap" type="com.example.demo.FileStatus">
        <id property="id.uuid" column="id" javaType="java.util.UUID" jdbcType="VARCHAR"/>
        <association property="status" javaType="com.example.demo.Status">
            <result property="status" column="status"/>
        </association>
        <result property="fileName" column="file_name"/>
    </resultMap>

    <insert id="insertFileStatus" parameterType="com.example.demo.FileStatus">
        INSERT INTO file_status (id, status, file_name) VALUES (#{id.uuid}, #{status.status}, #{fileName})
    </insert>

    <select id="getFileStatusById" parameterType="java.lang.String" resultMap="fileStatusResultMap">
        SELECT * FROM file_status WHERE id = #{id}
    </select>

    <update id="updateFileStatus" parameterType="com.example.demo.FileStatus">
        UPDATE file_status SET status = #{status.status}, file_name = #{fileName} WHERE id = #{id.uuid}
    </update>

    <delete id="deleteFileStatus" parameterType="java.lang.String">
        DELETE FROM file_status WHERE id = #{id}
    </delete>
</mapper>
```

### 3. DAO 클래스 정의

DAO 클래스 (`FileStatusMapper.java`)가 올바르게 매핑 파일을 사용하도록 설정합니다.

#### FileStatusMapper.java

```java
package com.example.demo.mapper;

import com.example.demo.FileStatus;
import org.apache.ibatis.annotations.*;

@Mapper
public interface FileStatusMapper {

    @Insert("INSERT INTO file_status (id, status, file_name) VALUES (#{id.uuid}, #{status.status}, #{fileName})")
    void insertFileStatus(FileStatus fileStatus);

    @Select("SELECT * FROM file_status WHERE id = #{id}")
    @ResultMap("fileStatusResultMap")
    FileStatus getFileStatusById(String id);

    @Update("UPDATE file_status SET status = #{status.status}, file_name = #{fileName} WHERE id = #{id.uuid}")
    void updateFileStatus(FileStatus fileStatus);

    @Delete("DELETE FROM file_status WHERE id = #{id}")
    void deleteFileStatus(String id);
}
```

### 4. Spring 설정 파일 확인

Spring 설정 파일 (`applicationContext.xml` 또는 `Spring Boot`의 경우 `application.yml`/`application.properties`)에서 MyBatis 관련 설정을 확인합니다.

#### application.yml (Spring Boot)

```yaml
spring:
  datasource:
    url: jdbc:mysql://localhost:3306/yourdatabase
    username: yourusername
    password: yourpassword
    driver-class-name: com.mysql.cj.jdbc.Driver

mybatis:
  config-location: classpath:mybatis-config.xml
  mapper-locations: classpath:mapper/*.xml
```

이 설정을 통해 MyBatis와 Spring Boot를 사용하여 객체가 두 단계로 감싸져 있을 때 바인딩 예외 오류를 해결할 수 있습니다. 주요 점은 SQL 문에서 참조하는 필드 이름이 Java 객체와 일치하는지, 데이터 타입이 일치하는지 확인하는 것입니다.






리눅스 서버에서 Jenkins와 Bitbucket을 사용하여 리액트 애플리케이션과 백엔드 애플리케이션을 자동으로 빌드 및 배포하는 파이프라인을 구축하는 방법을 단계별로 설명하겠습니다.

### 1. Jenkins 설치 및 설정

#### 1.1 Jenkins 설치

```sh
wget -q -O - https://pkg.jenkins.io/debian/jenkins.io.key | sudo apt-key add -
sudo sh -c 'echo deb http://pkg.jenkins.io/debian-stable binary/ > /etc/apt/sources.list.d/jenkins.list'
sudo apt update
sudo apt install jenkins
```

Jenkins를 시작합니다:

```sh
sudo systemctl start jenkins
sudo systemctl enable jenkins
```

#### 1.2 Jenkins 초기 설정

1. Jenkins 웹 인터페이스에 접속: `http://<your-server-ip>:8080`
2. 초기 관리자 비밀번호 입력: `/var/lib/jenkins/secrets/initialAdminPassword` 파일에서 비밀번호 확인
3. 기본 플러그인 설치
4. 관리자 계정 생성

### 2. Jenkins 플러그인 설치

Jenkins 관리 화면에서 다음 플러그인을 설치합니다:

- **Bitbucket Plugin**
- **Pipeline Plugin**
- **SSH Agent Plugin**

### 3. Bitbucket 리포지토리 설정

Bitbucket 리포지토리에 Webhook을 설정하여 코드가 푸시될 때 Jenkins가 빌드를 트리거하도록 설정합니다.

1. Bitbucket 리포지토리에 접속
2. Settings -> Webhooks -> Add webhook
3. Webhook URL: `http://<your-jenkins-server>:8080/bitbucket-hook/`
4. Triggers: Repository Push

### 4. Jenkins 파이프라인 설정

Jenkins에서 새로운 파이프라인을 생성하고, `Jenkinsfile`을 통해 빌드 및 배포 과정을 정의합니다.

#### 4.1 Jenkinsfile 작성

Jenkinsfile을 Bitbucket 리포지토리에 추가합니다.

```groovy
pipeline {
    agent any

    environment {
        DEPLOY_SERVER = 'your-deploy-server'
        DEPLOY_USER = 'your-deploy-user'
        DEPLOY_PATH = '/path/to/deploy'
        REPO_URL = 'https://bitbucket.org/your-repo-url.git'
    }

    stages {
        stage('Checkout') {
            steps {
                git url: "${REPO_URL}", credentialsId: 'your-credentials-id'
            }
        }

        stage('Install Node.js and NPM') {
            steps {
                script {
                    sh 'curl -sL https://deb.nodesource.com/setup_14.x | sudo -E bash -'
                    sh 'sudo apt-get install -y nodejs'
                }
            }
        }

        stage('Build React App') {
            steps {
                script {
                    sh 'npm install'
                    sh 'npm run build:prod'
                }
            }
        }

        stage('Build Backend') {
            steps {
                script {
                    // 예제: Gradle 빌드
                    sh './gradlew build'
                }
            }
        }

        stage('Deploy') {
            steps {
                sshagent(credentials: ['your-ssh-credentials-id']) {
                    sh """
                        scp -r build/libs/your-app.jar ${DEPLOY_USER}@${DEPLOY_SERVER}:${DEPLOY_PATH}
                        scp -r build/ ${DEPLOY_USER}@${DEPLOY_SERVER}:${DEPLOY_PATH}/frontend
                        ssh ${DEPLOY_USER}@${DEPLOY_SERVER} 'bash -s' < deploy.sh
                    """
                }
            }
        }
    }

    post {
        success {
            echo 'Deployment successful'
        }
        failure {
            echo 'Deployment failed'
        }
    }
}
```

#### 4.2 Jenkins 설정

Jenkins에서 새로운 파이프라인을 생성합니다.

1. Jenkins 대시보드 -> New Item -> Pipeline 선택
2. 파이프라인 이름 입력 -> OK
3. Pipeline script from SCM 선택
4. SCM: Git 선택
5. Repository URL 입력
6. Credentials: Jenkins에 저장된 Bitbucket 자격 증명 선택
7. Script Path: `Jenkinsfile` 입력

### 5. 배포 스크립트 작성

배포 서버에서 실행될 배포 스크립트를 작성합니다. 예를 들어, `deploy.sh` 파일을 작성합니다.

#### deploy.sh

```sh
#!/bin/bash

DEPLOY_PATH="/path/to/deploy"
JAR_FILE="your-app.jar"

# 애플리케이션 중지
pkill -f ${JAR_FILE}

# 백엔드 애플리케이션 배포
nohup java -jar ${DEPLOY_PATH}/${JAR_FILE} > ${DEPLOY_PATH}/app.log 2>&1 &

# 프론트엔드 파일 배포
FRONTEND_PATH="${DEPLOY_PATH}/frontend"
if [ -d "${FRONTEND_PATH}" ]; then
    sudo cp -r ${FRONTEND_PATH}/* /var/www/html/
fi
```

### 요약

1. **Jenkins 설치 및 초기 설정**: Jenkins를 설치하고 초기 설정을 완료합니다.
2. **Jenkins 플러그인 설치**: 필요한 플러그인(Bitbucket Plugin, Pipeline Plugin, SSH Agent Plugin)을 설치합니다.
3. **Bitbucket 리포지토리 설정**: Bitbucket에서 Webhook을 설정하여 Jenkins가 코드 푸시를 감지하고 빌드를 트리거하도록 합니다.
4. **Jenkins 파이프라인 설정**: Jenkins에서 파이프라인을 생성하고, `Jenkinsfile`을 작성하여 빌드 및 배포 단계를 정의합니다.
5. **배포 스크립트 작성**: 배포 서버에서 실행될 배포 스크립트를 작성하여 백엔드 및 프론트엔드 파일을 배포합니다.

이 과정을 통해 Jenkins와 Bitbucket을 사용하여 코드 푸시 시 리액트 애플리케이션과 백엔드 애플리케이션을 자동으로 빌드 및 배포하는 파이프라인을 구축할 수 있습니다.





리눅스 서버에서 Jenkins를 설정하고 Bitbucket을 사용하여 자동 배포 파이프라인을 구축하는 방법을 자세히 설명하겠습니다. 여기서는 Ubuntu를 예제로 사용합니다.

### 1. Jenkins 설치 및 설정

#### Jenkins 설치

```sh
wget -q -O - https://pkg.jenkins.io/debian/jenkins.io.key | sudo apt-key add -
sudo sh -c 'echo deb http://pkg.jenkins.io/debian-stable binary/ > /etc/apt/sources.list.d/jenkins.list'
sudo apt update
sudo apt install jenkins
```

Jenkins를 시작합니다:

```sh
sudo systemctl start jenkins
sudo systemctl enable jenkins
```

Jenkins 웹 인터페이스에 접속합니다: `http://<your-server-ip>:8080`

초기 관리자 비밀번호를 입력합니다:

```sh
sudo cat /var/lib/jenkins/secrets/initialAdminPassword
```

기본 플러그인을 설치하고 관리자 계정을 생성합니다.

### 2. Jenkins 플러그인 설치

Jenkins 관리 화면에서 다음 플러그인을 설치합니다:

- **Bitbucket Plugin**
- **Pipeline Plugin**
- **SSH Agent Plugin**

### 3. Bitbucket 리포지토리 설정

Bitbucket 리포지토리에 Webhook을 설정하여 코드가 푸시될 때 Jenkins가 빌드를 트리거하도록 설정합니다.

1. Bitbucket 리포지토리에 접속합니다.
2. Settings -> Webhooks -> Add webhook을 선택합니다.
3. Webhook URL을 입력합니다: `http://<your-jenkins-server>:8080/bitbucket-hook/`
4. Triggers에서 Repository Push를 선택합니다.

### 4. Jenkins 파이프라인 설정

Jenkins에서 새로운 파이프라인을 생성하고, `Jenkinsfile`을 통해 빌드 및 배포 과정을 정의합니다.

#### Jenkinsfile 예제

Jenkinsfile을 Bitbucket 리포지토리에 추가합니다.

```groovy
pipeline {
    agent any

    environment {
        DEPLOY_SERVER = 'your-deploy-server'
        DEPLOY_USER = 'your-deploy-user'
        DEPLOY_PATH = '/path/to/deploy'
        REPO_URL = 'https://bitbucket.org/your-repo-url.git'
    }

    stages {
        stage('Checkout') {
            steps {
                git url: "${REPO_URL}", credentialsId: 'your-credentials-id'
            }
        }
        
        stage('Build') {
            steps {
                script {
                    // 예제: Gradle 빌드
                    sh './gradlew build'
                }
            }
        }

        stage('Deploy') {
            steps {
                sshagent(credentials: ['your-ssh-credentials-id']) {
                    sh """
                        scp -r build/libs/your-app.jar ${DEPLOY_USER}@${DEPLOY_SERVER}:${DEPLOY_PATH}
                        ssh ${DEPLOY_USER}@${DEPLOY_SERVER} 'bash -s' < deploy.sh
                    """
                }
            }
        }
    }

    post {
        success {
            echo 'Deployment successful'
        }
        failure {
            echo 'Deployment failed'
        }
    }
}
```

### 5. Jenkins 설정

Jenkins에서 새로운 파이프라인을 생성합니다.

1. Jenkins 대시보드 -> New Item -> Pipeline을 선택합니다.
2. 파이프라인 이름을 입력하고 OK를 클릭합니다.
3. Pipeline script from SCM을 선택합니다.
4. SCM: Git을 선택합니다.
5. Repository URL을 입력합니다.
6. Credentials: Jenkins에 저장된 Bitbucket 자격 증명을 선택합니다.
7. Script Path에 `Jenkinsfile`을 입력합니다.

### 6. 배포 스크립트 작성

배포 서버에서 실행될 배포 스크립트를 작성합니다. 예를 들어, `deploy.sh` 파일을 작성합니다.

#### deploy.sh

```sh
#!/bin/bash

DEPLOY_PATH="/path/to/deploy"
JAR_FILE="your-app.jar"

# 애플리케이션 중지
pkill -f ${JAR_FILE}

# 새로운 애플리케이션 시작
nohup java -jar ${DEPLOY_PATH}/${JAR_FILE} > ${DEPLOY_PATH}/app.log 2>&1 &
```

### 요약

1. Jenkins 설치 및 초기 설정
2. Jenkins에 필요한 플러그인 설치
3. Bitbucket 리포지토리에 Webhook 설정
4. Jenkins에서 파이프라인을 생성하고 Jenkinsfile을 통해 빌드 및 배포 과정 정의
5. 배포 스크립트를 작성하여 배포 서버에서 실행

이 과정을 통해 Jenkins와 Bitbucket을 사용하여 코드 푸시 시 자동으로 빌드 및 배포하는 파이프라인을 구축할 수 있습니다.










<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE configuration
        PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-config.dtd">

<configuration>
    <settings>
        <setting name="cacheEnabled" value="true"/>
        <setting name="lazyLoadingEnabled" value="true"/>
        <setting name="multipleResultSetsEnabled" value="true"/>
        <setting name="useColumnLabel" value="true"/>
        <setting name="useGeneratedKeys" value="true"/>
    </settings>

    <typeAliases>
        <typeAlias type="com.example.demo.FileStatus" alias="FileStatus"/>
    </typeAliases>

    <mappers>
        <mapper resource="mapper/FileStatusMapper.xml"/>
    </mappers>
</configuration>







import org.apache.ibatis.session.SqlSessionFactory;
import org.mybatis.spring.SqlSessionFactoryBean;
import org.mybatis.spring.SqlSessionTemplate;
import org.mybatis.spring.annotation.MapperScan;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.core.io.support.PathMatchingResourcePatternResolver;

import javax.sql.DataSource;

@Configuration
@MapperScan("com.example.demo.mapper")
public class MyBatisConfig {

    @Bean
    public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
        SqlSessionFactoryBean sessionFactory = new SqlSessionFactoryBean();
        sessionFactory.setDataSource(dataSource);
        sessionFactory.setConfigLocation(
                new PathMatchingResourcePatternResolver().getResource("classpath:mybatis-config.xml"));
        return sessionFactory.getObject();
    }

    @Bean
    public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
        return new SqlSessionTemplate(sqlSessionFactory);
    }
}





import org.apache.ibatis.session.SqlSessionFactory;
import org.mybatis.spring.SqlSessionFactoryBean;
import org.mybatis.spring.annotation.MapperScan;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.core.io.support.PathMatchingResourcePatternResolver;

import javax.sql.DataSource;

@Configuration
@MapperScan("com.example.demo.mapper")
public class MyBatisConfig {

    @Bean
    public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
        SqlSessionFactoryBean sessionFactory = new SqlSessionFactoryBean();
        sessionFactory.setDataSource(dataSource);
        sessionFactory.setMapperLocations(
                new PathMatchingResourcePatternResolver().getResources("classpath:mapper/*.xml"));
        return sessionFactory.getObject();
    }
}



import org.apache.ibatis.annotations.Mapper;
import org.apache.ibatis.annotations.Param;
import com.example.demo.FileStatus;

@Mapper
public interface FileStatusMapper {
    void insertFileStatus(@Param("fileStatus") FileStatus fileStatus);

    FileStatus getFileStatusById(@Param("id") Long id);

    void updateFileStatus(@Param("fileStatus") FileStatus fileStatus);

    void deleteFileStatus(@Param("id") Long id);
}












import React, { useState, useEffect } from 'react';
import axios from 'axios';

const FileUpload = () => {
    const [selectedFile, setSelectedFile] = useState(null);
    const [uploadStatus, setUploadStatus] = useState('');
    const [downloadUrl, setDownloadUrl] = useState('');
    const [fileId, setFileId] = useState(null);

    const onFileChange = (event) => {
        setSelectedFile(event.target.files[0]);
    };

    const onFileUpload = async () => {
        const formData = new FormData();
        formData.append('file', selectedFile);

        try {
            const response = await axios.post('/api/upload', formData, {
                headers: {
                    'Content-Type': 'multipart/form-data'
                }
            });
            setUploadStatus('File uploaded successfully!');
            setFileId(response.data.id); // Assuming the backend returns the file ID
        } catch (error) {
            console.error('Error uploading file:', error);
            setUploadStatus('Error uploading file.');
        }
    };

    useEffect(() => {
        let interval;
        if (fileId) {
            interval = setInterval(async () => {
                try {
                    const response = await axios.get(`/api/status/${fileId}`);
                    if (response.data.status === 'COMPLETED') {
                        clearInterval(interval);
                        setDownloadUrl(`/api/download/${fileId}`);
                        setUploadStatus('File processing completed. You can download the file now.');
                    }
                } catch (error) {
                    console.error('Error checking status:', error);
                    setUploadStatus('Error checking status.');
                }
            }, 15000); // 15 seconds
        }
        return () => clearInterval(interval);
    }, [fileId]);

    return (
        <div>
            <h2>File Upload</h2>
            <input type="file" onChange={onFileChange} />
            <button onClick={onFileUpload}>Upload</button>
            <p>{uploadStatus}</p>
            {downloadUrl && <a href={downloadUrl} download>Download File</a>}
        </div>
    );
};

export default FileUpload;






import React, { useState } from 'react';
import axios from 'axios';

const FileUpload = () => {
    const [selectedFile, setSelectedFile] = useState(null);
    const [uploadStatus, setUploadStatus] = useState('');
    const [downloadUrl, setDownloadUrl] = useState('');

    const onFileChange = (event) => {
        setSelectedFile(event.target.files[0]);
    };

    const onFileUpload = async () => {
        const formData = new FormData();
        formData.append('file', selectedFile);

        try {
            const response = await axios.post('/api/upload', formData, {
                headers: {
                    'Content-Type': 'multipart/form-data'
                }
            });
            setUploadStatus('File uploaded successfully!');
            checkStatus(response.data.fileId);
        } catch (error) {
            console.error('Error uploading file:', error);
            setUploadStatus('Error uploading file.');
        }
    };

    const checkStatus = (fileId) => {
        const interval = setInterval(async () => {
            try {
                const response = await axios.get(`/api/status/${fileId}`);
                if (response.data.status === 'COMPLETED') {
                    clearInterval(interval);
                    setDownloadUrl(`/api/download/${fileId}`);
                    setUploadStatus('File processing completed. You can download the file now.');
                }
            } catch (error) {
                console.error('Error checking status:', error);
                setUploadStatus('Error checking status.');
            }
        }, 15000); // 15 seconds
    };

    return (
        <div>
            <h2>File Upload</h2>
            <input type="file" onChange={onFileChange} />
            <button onClick={onFileUpload}>Upload</button>
            <p>{uploadStatus}</p>
            {downloadUrl && <a href={downloadUrl} download>Download File</a>}
        </div>
    );
};

export default FileUpload;





plugins {
    id 'org.springframework.boot' version '2.7.2'
    id 'io.spring.dependency-management' version '1.0.11.RELEASE'
    id 'java'
}

group = 'com.example'
version = '0.0.1-SNAPSHOT'
sourceCompatibility = '11'

repositories {
    mavenCentral()
}

dependencies {
    implementation 'org.springframework.boot:spring-boot-starter'
    implementation 'org.springframework.boot:spring-boot-starter-web'
    implementation 'org.mybatis.spring.boot:mybatis-spring-boot-starter:2.1.4'
    runtimeOnly 'com.h2database:h2'

    testImplementation 'org.springframework.boot:spring-boot-starter-test'
}

test {
    useJUnitPlatform()
}





spring:
  datasource:
    url: jdbc:h2:mem:testdb
    driver-class-name: org.h2.Driver
    username: sa
    password:
  h2:
    console:
      enabled: true
  mybatis:
    mapper-locations: classpath:mappers/*.xml






public class User {
    private int id;
    private String name;
    private String email;

    // Getters and Setters
}






import org.apache.ibatis.annotations.*;

import java.util.List;

@Mapper
public interface UserMapper {

    @Insert("INSERT INTO users (name, email) VALUES (#{name}, #{email})")
    @Options(useGeneratedKeys = true, keyProperty = "id")
    void insertUser(User user);

    @Select("SELECT * FROM users WHERE id = #{id}")
    User getUserById(int id);

    @Select("SELECT * FROM users")
    List<User> getAllUsers();

    @Update("UPDATE users SET name = #{name}, email = #{email} WHERE id = #{id}")
    void updateUser(User user);

    @Delete("DELETE FROM users WHERE id = #{id}")
    void deleteUser(int id);
}






<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">

<mapper namespace="com.example.demo.mapper.UserMapper">
    <resultMap id="userResultMap" type="User">
        <id property="id" column="id" />
        <result property="name" column="name" />
        <result property="email" column="email" />
    </resultMap>

    <sql id="userColumns">id, name, email</sql>

    <insert id="insertUser" parameterType="User" useGeneratedKeys="true" keyProperty="id">
        INSERT INTO users (name, email)
        VALUES (#{name}, #{email})
    </insert>

    <select id="getUserById" parameterType="int" resultMap="userResultMap">
        SELECT <include refid="userColumns" />
        FROM users
        WHERE id = #{id}
    </select>

    <select id="getAllUsers" resultMap="userResultMap">
        SELECT <include refid="userColumns" />
        FROM users
    </select>

    <update id="updateUser" parameterType="User">
        UPDATE users
        SET name = #{name}, email = #{email}
        WHERE id = #{id}
    </update>

    <delete id="deleteUser" parameterType="int">
        DELETE FROM users
        WHERE id = #{id}
    </delete>
</mapper>



CREATE TABLE users (
    id INT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(255) NOT NULL,
    email VARCHAR(255) NOT NULL
);




import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.List;

@Service
public class UserService {

    @Autowired
    private UserMapper userMapper;

    public void insertUser(User user) {
        userMapper.insertUser(user);
    }

    public User getUserById(int id) {
        return userMapper.getUserById(id);
    }

    public List<User> getAllUsers() {
        return userMapper.getAllUsers();
    }

    public void updateUser(User user) {
        userMapper.updateUser(user);
    }

    public void deleteUser(int id) {
        userMapper.deleteUser(id);
    }
}




import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/users")
public class UserController {

    @Autowired
    private UserService userService;

    @PostMapping
    public String createUser(@RequestBody User user) {
        userService.insertUser(user);
        return "User created successfully!";
    }

    @GetMapping("/{id}")
    public User getUserById(@PathVariable int id) {
        return userService.getUserById(id);
    }

    @GetMapping
    public List<User> getAllUsers() {
        return userService.getAllUsers();
    }

    @PutMapping("/{id}")
    public String updateUser(@PathVariable int id, @RequestBody User user) {
        user.setId(id);
        userService.updateUser(user);
        return "User updated successfully!";
    }

    @DeleteMapping("/{id}")
    public String deleteUser(@PathVariable int id) {
        userService.deleteUser(id);
        return "User deleted successfully!";
    }
}


















import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class ApiResponse<T> {
    private T data;
    private String status;
    private String statusMessage;
}




import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/api")
public class HelloController {

    @GetMapping("/hello")
    public ApiResponse<String> hello() {
        return new ApiResponse<>("Hello, World!", "SUCCESS", "Request was successful");
    }
}





import org.apache.ibatis.annotations.Mapper;
import org.apache.ibatis.annotations.Param;

import java.util.List;
import java.util.Map;

@Mapper
public interface UserMapper {
    void insertUsers(@Param("users") List<Map<String, String>> users);
}

<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">

<mapper namespace="com.example.demo.mapper.UserMapper">
    <insert id="insertUsers">
        INSERT INTO users (username, email)
        VALUES
        <foreach collection="users" item="user" separator=",">
            (#{user.name}, #{user.mail})
        </foreach>
    </insert>
</mapper>


import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.Map;

@Service
public class UserService {

    @Autowired
    private UserMapper userMapper;

    @Transactional
    public void insertUsers(List<Map<String, String>> users) {
        userMapper.insertUsers(users);
    }
}

















import React, { useEffect } from 'react';
import { useForm } from 'react-hook-form';
import FileDropComponent from './FileDropComponent';

const App = () => {
    const { register, handleSubmit, watch } = useForm();
    const selectedFile = watch('file');

    useEffect(() => {
        if (selectedFile && selectedFile.length > 0) {
            const file = selectedFile[0];
            const acceptedTypes = ['application/vnd.ms-excel', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet', 'text/csv'];
            if (file && acceptedTypes.includes(file.type)) {
                handleFileUpload(file);
            } else {
                alert('Only .xls, .xlsx, .csv files are accepted.');
            }
        }
    }, [selectedFile]);

    const handleFileUpload = async (file) => {
        const formData = new FormData();
        formData.append('file', file);

        try {
            const response = await fetch('/api/upload', {
                method: 'POST',
                body: formData,
            });

            if (response.ok) {
                const result = await response.json();
                console.log('File uploaded successfully:', result);
            } else {
                console.error('File upload failed');
            }
        } catch (error) {
            console.error('Error uploading file:', error);
        }
    };

    const onSubmit = (data) => {
        console.log('Form Data:', data);
    };

    return (
        <form onSubmit={handleSubmit(onSubmit)}>
            <FileDropComponent register={register} />
            <button type="submit">Submit</button>
        </form>
    );
};

export default App;






import React, { useState, useRef } from 'react';

const FileDropComponent = ({ register }) => {
    const [isDragging, setIsDragging] = useState(false);
    const fileInputRef = useRef(null);

    const handleDragEnter = (e) => {
        e.preventDefault();
        e.stopPropagation();
        setIsDragging(true);
    };

    const handleDragLeave = (e) => {
        e.preventDefault();
        e.stopPropagation();
        setIsDragging(false);
    };

    const handleDragOver = (e) => {
        e.preventDefault();
        e.stopPropagation();
    };

    const handleDrop = (e) => {
        e.preventDefault();
        e.stopPropagation();
        setIsDragging(false);

        if (e.dataTransfer && e.dataTransfer.files) {
            const droppedFiles = Array.from(e.dataTransfer.files);
            const acceptedTypes = ['application/vnd.ms-excel', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet', 'text/csv'];

            if (droppedFiles.length > 1) {
                alert('Only one file is allowed.');
                return;
            }

            const file = droppedFiles.find(file => acceptedTypes.includes(file.type));

            if (file) {
                const dataTransfer = new DataTransfer();
                dataTransfer.items.add(file);
                fileInputRef.current.files = dataTransfer.files;
            } else {
                alert('Only .xls, .xlsx, .csv files are accepted.');
            }
        }
    };

    const handleFileChange = (e) => {
        const file = e.target.files[0];
        const acceptedTypes = ['application/vnd.ms-excel', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet', 'text/csv'];
        if (file && acceptedTypes.includes(file.type)) {
            const dataTransfer = new DataTransfer();
            dataTransfer.items.add(file);
            fileInputRef.current.files = dataTransfer.files;
        } else {
            alert('Only .xls, .xlsx, .csv files are accepted.');
        }
    };

    const handleDivClick = () => {
        if (fileInputRef.current) {
            fileInputRef.current.click();
        } else {
            console.error('File input ref is not assigned');
        }
    };

    return (
        <div
            onDragEnter={handleDragEnter}
            onDragLeave={handleDragLeave}
            onDragOver={handleDragOver}
            onDrop={handleDrop}
            onClick={handleDivClick}
            style={{
                border: '2px dashed #cccccc',
                borderRadius: '4px',
                padding: '20px',
                textAlign: 'center',
                backgroundColor: isDragging ? '#e9e9e9' : '#ffffff',
                cursor: 'pointer'
            }}
        >
            <input
                type="file"
                style={{ display: 'none' }}
                {...register('file', {
                    required: 'A file is required'
                })}
                ref={fileInputRef}
                onChange={handleFileChange}
            />
            <p>{isDragging ? 'Drop the file here...' : 'Drag & drop a file here, or click to select a file'}</p>
        </div>
    );
};

export default FileDropComponent;






















import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class HashMapListExample {
    public static void main(String[] args) {
        // HashMap 객체들을 저장할 ArrayList 생성
        List<Map<String, Object>> hashMapList = new ArrayList<>();

        // 예제 데이터 (이 부분은 실제 사용 사례에 따라 달라질 수 있음)
        String[] names = {"Alice", "Bob", "Charlie"};
        int[] ages = {25, 30, 35};

        // for문을 사용하여 각 HashMap을 생성하고 리스트에 추가
        for (int i = 0; i < names.length; i++) {
            Map<String, Object> personMap = new HashMap<>();
            personMap.put("name", names[i]);
            personMap.put("age", ages[i]);

            // 생성된 HashMap을 리스트에 추가
            hashMapList.add(personMap);
        }

        // 리스트와 그 내용 출력
        System.out.println(hashMapList);
        for (Map<String, Object> person : hashMapList) {
            System.out.println("Name: " + person.get("name") + ", Age: " + person.get("age"));
        }
    }
}









import React, { useState } from 'react';

const FileDropComponent = ({ register }) => {
    const [isDragging, setIsDragging] = useState(false);
    const [file, setFile] = useState(null);

    const handleDragEnter = (e) => {
        e.preventDefault();
        e.stopPropagation();
        setIsDragging(true);
    };

    const handleDragLeave = (e) => {
        e.preventDefault();
        e.stopPropagation();
        setIsDragging(false);
    };

    const handleDragOver = (e) => {
        e.preventDefault();
        e.stopPropagation();
    };

    const handleDrop = (e) => {
        e.preventDefault();
        e.stopPropagation();
        setIsDragging(false);

        const droppedFiles = Array.from(e.dataTransfer.files);
        const acceptedTypes = ['application/vnd.ms-excel', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet', 'text/csv'];

        if (droppedFiles.length > 1) {
            alert('Only one file is allowed.');
            return;
        }

        const file = droppedFiles.find(file => acceptedTypes.includes(file.type));

        if (file) {
            setFile(file);
            handleFileUpload(file);
        } else {
            alert('Only .xls, .xlsx, .csv files are accepted.');
        }
    };

    const handleFileUpload = async (file) => {
        const formData = new FormData();
        formData.append('file', file);

        try {
            const response = await fetch('/api/upload', {
                method: 'POST',
                body: formData,
            });

            if (response.ok) {
                const result = await response.json();
                console.log('File uploaded successfully:', result);
            } else {
                console.error('File upload failed');
            }
        } catch (error) {
            console.error('Error uploading file:', error);
        }
    };

    const handleFileChange = (e) => {
        const file = e.target.files[0];
        const acceptedTypes = ['application/vnd.ms-excel', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet', 'text/csv'];
        if (file && acceptedTypes.includes(file.type)) {
            setFile(file);
            handleFileUpload(file);
        } else {
            alert('Only .xls, .xlsx, .csv files are accepted.');
        }
    };

    return (
        <div
            onDragEnter={handleDragEnter}
            onDragLeave={handleDragLeave}
            onDragOver={handleDragOver}
            onDrop={handleDrop}
            style={{
                border: '2px dashed #cccccc',
                borderRadius: '4px',
                padding: '20px',
                textAlign: 'center',
                backgroundColor: isDragging ? '#e9e9e9' : '#ffffff',
                cursor: 'pointer'
            }}
        >
            <input
                type="file"
                style={{ display: 'none' }}
                {...register('file', {
                    required: 'A file is required'
                })}
                onChange={handleFileChange}
            />
            <p>{isDragging ? 'Drop the file here...' : 'Drag & drop a file here, or click to select a file'}</p>
            {file && <p>Selected file: {file.name}</p>}
        </div>
    );
};

export default FileDropComponent;








import React, { useState } from 'react';

const FileDropComponent = ({ register, onFileSelect }) => {
    const [isDragging, setIsDragging] = useState(false);

    const handleDragEnter = (e) => {
        e.preventDefault();
        e.stopPropagation();
        setIsDragging(true);
    };

    const handleDragLeave = (e) => {
        e.preventDefault();
        e.stopPropagation();
        setIsDragging(false);
    };

    const handleDragOver = (e) => {
        e.preventDefault();
        e.stopPropagation();
    };

    const handleDrop = (e) => {
        e.preventDefault();
        e.stopPropagation();
        setIsDragging(false);

        const droppedFiles = Array.from(e.dataTransfer.files);
        const acceptedTypes = ['application/vnd.ms-excel', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet', 'text/csv'];

        if (droppedFiles.length > 1) {
            alert('Only one file is allowed.');
            return;
        }

        const file = droppedFiles.find(file => acceptedTypes.includes(file.type));

        if (file) {
            onFileSelect(file);
        } else {
            alert('Only .xls, .xlsx, .csv files are accepted.');
        }
    };

    const handleFileChange = (e) => {
        const file = e.target.files[0];
        const acceptedTypes = ['application/vnd.ms-excel', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet', 'text/csv'];
        if (file && acceptedTypes.includes(file.type)) {
            onFileSelect(file);
        } else {
            alert('Only .xls, .xlsx, .csv files are accepted.');
        }
    };

    return (
        <div
            onDragEnter={handleDragEnter}
            onDragLeave={handleDragLeave}
            onDragOver={handleDragOver}
            onDrop={handleDrop}
            style={{
                border: '2px dashed #cccccc',
                borderRadius: '4px',
                padding: '20px',
                textAlign: 'center',
                backgroundColor: isDragging ? '#e9e9e9' : '#ffffff',
                cursor: 'pointer'
            }}
        >
            <input
                type="file"
                style={{ display: 'none' }}
                {...register('file', {
                    required: 'A file is required'
                })}
                onChange={handleFileChange}
            />
            <p>{isDragging ? 'Drop the file here...' : 'Drag & drop a file here, or click to select a file'}</p>
        </div>
    );
};

export default FileDropComponent;








<configuration>
    <property name="LOG_PATH" value="logs" />
    <property name="LOG_FILE" value="${LOG_PATH}/application.log" />

    <!-- 콘솔 출력 설정 -->
    <appender name="Console" class="ch.qos.logback.core.ConsoleAppender">
        <encoder>
            <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n</pattern>
        </encoder>
    </appender>

    <!-- 파일 출력 설정 -->
    <appender name="File" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <file>${LOG_FILE}</file>
        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <!-- 로그 파일 롤링 설정 (일별 롤링) -->
            <fileNamePattern>${LOG_PATH}/application.%d{yyyy-MM-dd}.log</fileNamePattern>
            <maxHistory>30</maxHistory>
        </rollingPolicy>
        <encoder>
            <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n</pattern>
        </encoder>
    </appender>

    <root level="info">
        <appender-ref ref="Console" />
        <appender-ref ref="File" />
    </root>
</configuration>