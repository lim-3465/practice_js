현재 제공된 코드는 한 시간 반(90분)이 지나면 새로운 엑세스 토큰을 자동으로 받아오도록 설계되어 있습니다. 그러나 에러가 발생했을 때도 토큰을 갱신할 수 있도록 추가적인 로직을 구현하는 것이 필요합니다. 일반적으로 API 서버에서 엑세스 토큰 만료 시 “401 Unauthorized”와 같은 상태 코드가 반환될 수 있습니다. 이 경우에 토큰을 재발급하고, 다시 요청을 시도하는 로직을 추가할 수 있습니다.

import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import org.springframework.http.ResponseEntity;
import org.springframework.util.LinkedMultiValueMap;
import org.springframework.util.MultiValueMap;

@Service
public class TokenService {
    
    private static final String TOKEN_URL = "https://thirdparty.com/oauth/token";

    // 엑세스 토큰을 받아오는 메소드
    public String fetchAccessToken() {
        RestTemplate restTemplate = new RestTemplate();

        // 폼 데이터 설정
        MultiValueMap<String, String> requestData = new LinkedMultiValueMap<>();
        requestData.add("grant_type", "client_credentials");
        requestData.add("client_id", "your_client_id");
        requestData.add("client_secret", "your_client_secret");

        // POST 요청으로 토큰 가져오기
        ResponseEntity<TokenResponse> response = restTemplate.postForEntity(TOKEN_URL, requestData, TokenResponse.class);
        
        return response.getBody().getAccessToken(); // 토큰을 반환
    }

    // 응답 데이터를 담을 클래스
    public static class TokenResponse {
        private String access_token;

        public String getAccessToken() {
            return access_token;
        }

        public void setAccessToken(String access_token) {
            this.access_token = access_token;
        }
    }
}









이를 위해 RestTemplate에 재시도 로직을 추가하고, 401 상태 코드가 발생했을 때 엑세스 토큰을 갱신하는 방식을 적용할 수 있습니다.

수정된 로직 (401 에러 시 토큰 갱신 및 재시도)

	1.	토큰 갱신 인터셉터 작성:
	•	요청이 실패하고 401 에러가 발생하면 토큰을 새로 받아오고, 다시 요청을 시도하는 로직을 구현합니다.
	2.	RestTemplateBuilder에 인터셉터 적용**:
	•	ClientHttpRequestInterceptor를 사용하여 재시도 로직을 추가합니다.

구현 코드:

import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpMethod;
import org.springframework.http.HttpRequest;
import org.springframework.http.client.ClientHttpRequestExecution;
import org.springframework.http.client.ClientHttpRequestInterceptor;
import org.springframework.http.client.ClientHttpResponse;
import org.springframework.stereotype.Component;
import org.springframework.web.client.RestTemplate;

import java.io.IOException;

@Component
public class RetryableTokenInterceptor implements ClientHttpRequestInterceptor {

    private final CachedTokenService cachedTokenService;

    public RetryableTokenInterceptor(CachedTokenService cachedTokenService) {
        this.cachedTokenService = cachedTokenService;
    }

    @Override
    public ClientHttpResponse intercept(HttpRequest request, byte[] body, ClientHttpRequestExecution execution) throws IOException {
        // 엑세스 토큰을 헤더에 추가
        String accessToken = cachedTokenService.getAccessToken();
        request.getHeaders().add("Authorization", "Bearer " + accessToken);

        // 요청을 실행
        ClientHttpResponse response = execution.execute(request, body);

        // 401 상태 코드인 경우 토큰 갱신 및 재시도 로직
        if (response.getStatusCode().value() == 401) {
            // 새로운 토큰 요청
            String newAccessToken = cachedTokenService.getAccessToken(true); // 강제로 토큰 갱신

            // 기존 요청에 새로운 토큰을 추가하여 다시 실행
            request.getHeaders().remove("Authorization");
            request.getHeaders().add("Authorization", "Bearer " + newAccessToken);

            // 재시도
            response = execution.execute(request, body);
        }

        return response;
    }
}

수정된 CachedTokenService 클래스 (강제 토큰 갱신 로직 포함)

import org.springframework.stereotype.Service;

import java.time.Instant;

@Service
public class CachedTokenService {

    private final TokenService tokenService;

    private Instant tokenExpiryTime;
    private String cachedToken;

    public CachedTokenService(TokenService tokenService) {
        this.tokenService = tokenService;
    }

    // 토큰 만료 시간 확인 및 갱신 (forceRenew = true면 강제 갱신)
    public String getAccessToken() {
        return getAccessToken(false);
    }

    public String getAccessToken(boolean forceRenew) {
        if (forceRenew || cachedToken == null || Instant.now().isAfter(tokenExpiryTime)) {
            cachedToken = tokenService.fetchAccessToken();
            // 토큰 발급 후 90분 동안 유효
            tokenExpiryTime = Instant.now().plusSeconds(90 * 60);
        }
        return cachedToken;
    }
}

RestTemplate 설정에 인터셉터 추가

import org.springframework.boot.web.client.RestTemplateBuilder;
import org.springframework.context.annotation.Bean;
import org.springframework.stereotype.Component;
import org.springframework.web.client.RestTemplate;

import java.time.Duration;

@Component
public class RestTemplateConfig {

    private final RetryableTokenInterceptor retryableTokenInterceptor;

    public RestTemplateConfig(RetryableTokenInterceptor retryableTokenInterceptor) {
        this.retryableTokenInterceptor = retryableTokenInterceptor;
    }

    @Bean
    public RestTemplate restTemplate(RestTemplateBuilder builder) {
        return builder
                .setConnectTimeout(Duration.ofSeconds(30))
                .setReadTimeout(Duration.ofSeconds(30))
                .additionalInterceptors(retryableTokenInterceptor)
                .build();
    }
}

설명:

	1.	RetryableTokenInterceptor: 이 인터셉터는 HTTP 요청을 보내기 전 Authorization 헤더에 엑세스 토큰을 추가하고, 서버 응답이 401 (Unauthorized) 일 경우 엑세스 토큰을 새로 발급받아 요청을 재시도하는 로직을 포함합니다.
	•	토큰 갱신 및 재시도: 요청이 401 오류를 반환하면, 새로운 토큰을 발급받고 원래 요청을 재시도합니다.
	2.	CachedTokenService:
	•	기본적으로 90분 동안 캐시된 토큰을 반환하지만, forceRenew 플래그가 true로 설정되면 강제로 새로운 토큰을 발급받습니다.
	3.	RestTemplateConfig:
	•	RestTemplate에 인터셉터를 추가하여 모든 요청이 이 인터셉터를 거치도록 설정합니다.

전체 흐름:

	1.	정상적인 요청: 엑세스 토큰이 유효한 동안에는 캐싱된 토큰을 사용하여 요청을 보냅니다.
	2.	401 오류 발생 시: 엑세스 토큰이 만료되었거나 유효하지 않은 경우, 401 상태 코드를 감지하여 새로운 토큰을 발급받고, 동일한 요청을 다시 시도합니다.
	3.	강제 토큰 갱신: CachedTokenService는 기본적으로 캐시된 토큰을 반환하지만, 401 오류가 발생하면 강제로 토큰을 갱신합니다.

이렇게 구현하면 한 시간 반 동안 유효한 토큰을 사용하며, 토큰이 만료되거나 401 오류가 발생할 때마다 새로운 토큰을 받아 다시 요청을 시도할 수 있습니다.