ğŸš€ Access Token ë§Œë£Œì™€ ì¿ í‚¤, 401 ì—ëŸ¬ì˜ ê´€ê³„

ğŸ“š 1. Access Token ë§Œë£Œì™€ ì¿ í‚¤ì˜ ì—­í• 
	â€¢	Access Token ë§Œë£Œ ì‹œê°„ì€ JWTì˜ exp(Expiration) í´ë ˆì„ê³¼ ì¿ í‚¤ì˜ maxAgeì— ì˜í•´ ì •ì˜ë©ë‹ˆë‹¤.
	â€¢	ì¿ í‚¤ ë§Œë£Œì™€ Access Token ë§Œë£ŒëŠ” ë³„ê°œì´ì§€ë§Œ ìƒí˜¸ì‘ìš©í•©ë‹ˆë‹¤.

âœ… 2. íë¦„ ì„¤ëª…

ğŸ“ 1. Access Tokenê³¼ ì¿ í‚¤ ë§Œë£Œ ì‹œê°„ ì„¤ì •
	â€¢	Access Tokenì˜ ë§Œë£Œ ì‹œê°„(exp)ì€ JWT ë‚´ë¶€ì— ì„¤ì •ë©ë‹ˆë‹¤.
	â€¢	ì¿ í‚¤(HttpOnly)ì—ë„ maxAge ë˜ëŠ” Expires ì†ì„±ìœ¼ë¡œ ë§Œë£Œ ì‹œê°„ì´ ì„¤ì •ë©ë‹ˆë‹¤.

ì˜ˆì‹œ:

ResponseCookie accessTokenCookie = ResponseCookie.from("access_token", accessToken)
        .httpOnly(true)
        .secure(true)
        .path("/")
        .maxAge((expiration.getTime() - System.currentTimeMillis()) / 1000) // JWT ë§Œë£Œ ì‹œê°„ê³¼ ë™ì¼
        .sameSite("Strict")
        .build();

ğŸ“ 2. í´ë¼ì´ì–¸íŠ¸ ìš”ì²­ íë¦„
	1.	ì‚¬ìš©ìëŠ” Access Tokenì„ HttpOnly ì¿ í‚¤ì— ì €ì¥í•©ë‹ˆë‹¤.
	2.	HTTP ìš”ì²­ ì‹œ ë¸Œë¼ìš°ì €ëŠ” ì¿ í‚¤ì— í¬í•¨ëœ Access Tokenì„ ì„œë²„ë¡œ ì „ì†¡í•©ë‹ˆë‹¤.
	3.	ì„œë²„ëŠ” JwtAuthenticationFilterì—ì„œ Access Tokenì„ ê²€ì¦í•©ë‹ˆë‹¤.

âœ… 3. Access Token ê²€ì¦ ê³¼ì •

ğŸ“ JwtAuthenticationFilter.java

@Override
protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)
        throws ServletException, IOException {

    String accessToken = extractTokenFromCookie(request);

    if (accessToken != null) {
        try {
            if (!tokenValidator.validateToken(accessToken)) {
                throw new RuntimeException("Token expired");
            }

            String username = tokenValidator.getUsernameFromToken(accessToken);
            UsernamePasswordAuthenticationToken authentication =
                new UsernamePasswordAuthenticationToken(username, null, tokenValidator.getAuthorities(accessToken));

            SecurityContextHolder.getContext().setAuthentication(authentication);
        } catch (Exception e) {
            // âœ… ë§Œë£Œëœ ê²½ìš° 401 ë°˜í™˜
            response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
            response.getWriter().write("{\"error\":\"TOKEN_EXPIRED\"}");
            return;
        }
    } else {
        // âœ… ì¿ í‚¤ì— Access Tokenì´ ì—†ëŠ” ê²½ìš°
        response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
        response.getWriter().write("{\"error\":\"TOKEN_MISSING\"}");
        return;
    }

    filterChain.doFilter(request, response);
}

private String extractTokenFromCookie(HttpServletRequest request) {
    if (request.getCookies() != null) {
        for (Cookie cookie : request.getCookies()) {
            if ("access_token".equals(cookie.getName())) {
                return cookie.getValue();
            }
        }
    }
    return null;
}

âœ… 4. ì‹œë‚˜ë¦¬ì˜¤ë³„ ë™ì‘ ë°©ì‹

ìƒí™©	Access Token ìƒíƒœ	ì¿ í‚¤ ìƒíƒœ	ê²°ê³¼
1. ìœ íš¨í•œ í† í°	ë§Œë£Œë˜ì§€ ì•ŠìŒ	ì¿ í‚¤ ì¡´ì¬	âœ… ì •ìƒ ì²˜ë¦¬
2. ë§Œë£Œëœ í† í°	ë§Œë£Œë¨	ì¿ í‚¤ ì¡´ì¬	âŒ 401 Unauthorized ë°˜í™˜
3. ì¿ í‚¤ ë§Œë£Œ	-	ì¿ í‚¤ ì—†ìŒ	âŒ 401 Unauthorized ë°˜í™˜ (TOKEN_MISSING)
4. í† í° ë³€ì¡°	ìœ íš¨í•˜ì§€ ì•ŠìŒ	ì¿ í‚¤ ì¡´ì¬	âŒ 401 Unauthorized ë°˜í™˜

ğŸ”‘ ì„¤ëª…
	1.	ë§Œë£Œëœ í† í°
	â€¢	í† í°ì€ ì¿ í‚¤ì— ë‚¨ì•„ìˆì§€ë§Œ expê°€ ì§€ë‚˜ë©´ validateTokenì—ì„œ ë§Œë£Œë¡œ íŒë‹¨í•˜ê³  401 ì—ëŸ¬ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.
	2.	ì¿ í‚¤ê°€ ë§Œë£Œë¨
	â€¢	ë¸Œë¼ìš°ì €ê°€ ë§Œë£Œëœ ì¿ í‚¤ë¥¼ ìë™ìœ¼ë¡œ ì‚­ì œí•©ë‹ˆë‹¤.
	â€¢	ì„œë²„ì— Access Tokenì´ ì „ì†¡ë˜ì§€ ì•Šì•„ì„œ extractTokenFromCookieê°€ nullì„ ë°˜í™˜í•©ë‹ˆë‹¤.
	â€¢	ì„œë²„ëŠ” 401 Unauthorized ì˜¤ë¥˜ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.

âœ… 5. ì¿ í‚¤ì™€ Access Token ì‹œê°„ ì¼ì¹˜

ğŸ“ Access Tokenê³¼ ì¿ í‚¤ ë§Œë£Œ ì‹œê°„ ë™ê¸°í™”
	â€¢	**Access Token ë§Œë£Œ ì‹œê°„(exp)**ê³¼ **ì¿ í‚¤ ë§Œë£Œ ì‹œê°„(maxAge)**ì„ ì¼ì¹˜ì‹œì¼œì•¼ í•©ë‹ˆë‹¤.
	â€¢	ì„¤ì • ì˜ˆì‹œ:

Date expiration = tokenValidator.getExpirationDateFromToken(accessToken);

ResponseCookie accessTokenCookie = ResponseCookie.from("access_token", accessToken)
        .httpOnly(true)
        .secure(true)
        .path("/")
        .maxAge((expiration.getTime() - System.currentTimeMillis()) / 1000)
        .sameSite("Strict")
        .build();

ğŸ”‘ ì„¤ëª…
	â€¢	maxAgeëŠ” JWTì˜ ë§Œë£Œ ì‹œê°„ê³¼ ì¼ì¹˜í•´ì•¼ í•©ë‹ˆë‹¤.
	â€¢	ì¼ì¹˜í•˜ì§€ ì•Šìœ¼ë©´ JWTëŠ” ìœ íš¨í•˜ì§€ë§Œ ì¿ í‚¤ê°€ ì‚­ì œë˜ì–´ ìš”ì²­í•  ìˆ˜ ì—†ëŠ” ë¬¸ì œê°€ ë°œìƒí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

âœ… 6. í”„ë¡ íŠ¸ì—”ë“œ ì²˜ë¦¬ (React)

ğŸ“ Axios Interceptorë¡œ 401 ì—ëŸ¬ ì²˜ë¦¬

import axios from 'axios';

axios.defaults.withCredentials = true;

// Axios Interceptor
axios.interceptors.response.use(
    response => response,
    error => {
        if (error.response && error.response.status === 401) {
            if (error.response.data.error === "TOKEN_MISSING") {
                console.warn('Token missing, redirecting to login...');
            } else if (error.response.data.error === "TOKEN_EXPIRED") {
                console.warn('Token expired, redirecting to re-authenticate...');
            }
            window.location.href = '/oauth/authorize';
        }
        return Promise.reject(error);
    }
);

âœ… 7. ìµœì¢… íë¦„
	1.	Access Token ìœ íš¨:
	â€¢	ìš”ì²­ ì²˜ë¦¬ ì •ìƒ ì‘ë™.
	2.	Access Token ë§Œë£Œ (exp ì§€ë‚¨):
	â€¢	401 Unauthorizedì™€ TOKEN_EXPIRED ì‘ë‹µ.
	â€¢	Reactê°€ /oauth/authorizeë¡œ ë¦¬ë‹¤ì´ë ‰ì…˜.
	3.	ì¿ í‚¤ ë§Œë£Œ:
	â€¢	Access Tokenì´ ì„œë²„ë¡œ ì „ë‹¬ë˜ì§€ ì•ŠìŒ.
	â€¢	401 Unauthorizedì™€ TOKEN_MISSING ì‘ë‹µ.
	â€¢	Reactê°€ /oauth/authorizeë¡œ ë¦¬ë‹¤ì´ë ‰ì…˜.
	4.	ë‹¤ì‹œ Access Codeë¥¼ ìš”ì²­:
	â€¢	ì‚¬ìš©ìëŠ” /oauth/authorizeì—ì„œ Access Codeë¥¼ ë°›ì•„ Access Tokenì„ ì¬ë°œê¸‰.

âœ… 8. ìµœì¢… ì •ë¦¬
	â€¢	Access Token ë§Œë£ŒëŠ” JWTì˜ exp í´ë ˆì„ìœ¼ë¡œ í™•ì¸í•©ë‹ˆë‹¤.
	â€¢	ë¸Œë¼ìš°ì € ì¿ í‚¤ ë§Œë£ŒëŠ” maxAgeë‚˜ Expires ì†ì„±ìœ¼ë¡œ í™•ì¸í•©ë‹ˆë‹¤.
	â€¢	Access Token ë§Œë£Œ: 401 Unauthorizedì™€ TOKEN_EXPIRED ë°˜í™˜.
	â€¢	ì¿ í‚¤ ë§Œë£Œ: 401 Unauthorizedì™€ TOKEN_MISSING ë°˜í™˜.
	â€¢	í”„ë¡ íŠ¸ì—”ë“œì—ì„œ 401 ì‘ë‹µì„ ê°ì§€í•´ /oauth/authorizeë¡œ ë¦¬ë””ë ‰ì…˜.

ì´ì œ Access Tokenê³¼ ì¿ í‚¤ ë§Œë£Œë¥¼ ì•ˆì „í•˜ê²Œ ë‹¤ë£¨ê³  ì¬ì¸ì¦ì„ ìœ ë„í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤! ğŸš€ğŸ”âœ¨





ğŸš€ Access Token ë§Œë£Œì™€ ì¿ í‚¤, 401 ì—ëŸ¬ì˜ ê´€ê³„

ğŸ“š 1. Access Token ë§Œë£Œì™€ ì¿ í‚¤ì˜ ì—­í• 
	â€¢	Access Token ë§Œë£Œ ì‹œê°„ì€ JWTì˜ exp(Expiration) í´ë ˆì„ê³¼ ì¿ í‚¤ì˜ maxAgeì— ì˜í•´ ì •ì˜ë©ë‹ˆë‹¤.
	â€¢	ì¿ í‚¤ ë§Œë£Œì™€ Access Token ë§Œë£ŒëŠ” ë³„ê°œì´ì§€ë§Œ ìƒí˜¸ì‘ìš©í•©ë‹ˆë‹¤.

âœ… 2. íë¦„ ì„¤ëª…

ğŸ“ 1. Access Tokenê³¼ ì¿ í‚¤ ë§Œë£Œ ì‹œê°„ ì„¤ì •
	â€¢	Access Tokenì˜ ë§Œë£Œ ì‹œê°„(exp)ì€ JWT ë‚´ë¶€ì— ì„¤ì •ë©ë‹ˆë‹¤.
	â€¢	ì¿ í‚¤(HttpOnly)ì—ë„ maxAge ë˜ëŠ” Expires ì†ì„±ìœ¼ë¡œ ë§Œë£Œ ì‹œê°„ì´ ì„¤ì •ë©ë‹ˆë‹¤.

ì˜ˆì‹œ:

ResponseCookie accessTokenCookie = ResponseCookie.from("access_token", accessToken)
        .httpOnly(true)
        .secure(true)
        .path("/")
        .maxAge((expiration.getTime() - System.currentTimeMillis()) / 1000) // JWT ë§Œë£Œ ì‹œê°„ê³¼ ë™ì¼
        .sameSite("Strict")
        .build();

ğŸ“ 2. í´ë¼ì´ì–¸íŠ¸ ìš”ì²­ íë¦„
	1.	ì‚¬ìš©ìëŠ” Access Tokenì„ HttpOnly ì¿ í‚¤ì— ì €ì¥í•©ë‹ˆë‹¤.
	2.	HTTP ìš”ì²­ ì‹œ ë¸Œë¼ìš°ì €ëŠ” ì¿ í‚¤ì— í¬í•¨ëœ Access Tokenì„ ì„œë²„ë¡œ ì „ì†¡í•©ë‹ˆë‹¤.
	3.	ì„œë²„ëŠ” JwtAuthenticationFilterì—ì„œ Access Tokenì„ ê²€ì¦í•©ë‹ˆë‹¤.

âœ… 3. Access Token ê²€ì¦ ê³¼ì •

ğŸ“ JwtAuthenticationFilter.java

@Override
protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)
        throws ServletException, IOException {

    String accessToken = extractTokenFromCookie(request);

    if (accessToken != null) {
        try {
            if (!tokenValidator.validateToken(accessToken)) {
                throw new RuntimeException("Token expired");
            }

            String username = tokenValidator.getUsernameFromToken(accessToken);
            UsernamePasswordAuthenticationToken authentication =
                new UsernamePasswordAuthenticationToken(username, null, tokenValidator.getAuthorities(accessToken));

            SecurityContextHolder.getContext().setAuthentication(authentication);
        } catch (Exception e) {
            // âœ… ë§Œë£Œëœ ê²½ìš° 401 ë°˜í™˜
            response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
            response.getWriter().write("{\"error\":\"TOKEN_EXPIRED\"}");
            return;
        }
    } else {
        // âœ… ì¿ í‚¤ì— Access Tokenì´ ì—†ëŠ” ê²½ìš°
        response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
        response.getWriter().write("{\"error\":\"TOKEN_MISSING\"}");
        return;
    }

    filterChain.doFilter(request, response);
}

private String extractTokenFromCookie(HttpServletRequest request) {
    if (request.getCookies() != null) {
        for (Cookie cookie : request.getCookies()) {
            if ("access_token".equals(cookie.getName())) {
                return cookie.getValue();
            }
        }
    }
    return null;
}

âœ… 4. ì‹œë‚˜ë¦¬ì˜¤ë³„ ë™ì‘ ë°©ì‹

ìƒí™©	Access Token ìƒíƒœ	ì¿ í‚¤ ìƒíƒœ	ê²°ê³¼
1. ìœ íš¨í•œ í† í°	ë§Œë£Œë˜ì§€ ì•ŠìŒ	ì¿ í‚¤ ì¡´ì¬	âœ… ì •ìƒ ì²˜ë¦¬
2. ë§Œë£Œëœ í† í°	ë§Œë£Œë¨	ì¿ í‚¤ ì¡´ì¬	âŒ 401 Unauthorized ë°˜í™˜
3. ì¿ í‚¤ ë§Œë£Œ	-	ì¿ í‚¤ ì—†ìŒ	âŒ 401 Unauthorized ë°˜í™˜ (TOKEN_MISSING)
4. í† í° ë³€ì¡°	ìœ íš¨í•˜ì§€ ì•ŠìŒ	ì¿ í‚¤ ì¡´ì¬	âŒ 401 Unauthorized ë°˜í™˜

ğŸ”‘ ì„¤ëª…
	1.	ë§Œë£Œëœ í† í°
	â€¢	í† í°ì€ ì¿ í‚¤ì— ë‚¨ì•„ìˆì§€ë§Œ expê°€ ì§€ë‚˜ë©´ validateTokenì—ì„œ ë§Œë£Œë¡œ íŒë‹¨í•˜ê³  401 ì—ëŸ¬ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.
	2.	ì¿ í‚¤ê°€ ë§Œë£Œë¨
	â€¢	ë¸Œë¼ìš°ì €ê°€ ë§Œë£Œëœ ì¿ í‚¤ë¥¼ ìë™ìœ¼ë¡œ ì‚­ì œí•©ë‹ˆë‹¤.
	â€¢	ì„œë²„ì— Access Tokenì´ ì „ì†¡ë˜ì§€ ì•Šì•„ì„œ extractTokenFromCookieê°€ nullì„ ë°˜í™˜í•©ë‹ˆë‹¤.
	â€¢	ì„œë²„ëŠ” 401 Unauthorized ì˜¤ë¥˜ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.

âœ… 5. ì¿ í‚¤ì™€ Access Token ì‹œê°„ ì¼ì¹˜

ğŸ“ Access Tokenê³¼ ì¿ í‚¤ ë§Œë£Œ ì‹œê°„ ë™ê¸°í™”
	â€¢	**Access Token ë§Œë£Œ ì‹œê°„(exp)**ê³¼ **ì¿ í‚¤ ë§Œë£Œ ì‹œê°„(maxAge)**ì„ ì¼ì¹˜ì‹œì¼œì•¼ í•©ë‹ˆë‹¤.
	â€¢	ì„¤ì • ì˜ˆì‹œ:

Date expiration = tokenValidator.getExpirationDateFromToken(accessToken);

ResponseCookie accessTokenCookie = ResponseCookie.from("access_token", accessToken)
        .httpOnly(true)
        .secure(true)
        .path("/")
        .maxAge((expiration.getTime() - System.currentTimeMillis()) / 1000)
        .sameSite("Strict")
        .build();

ğŸ”‘ ì„¤ëª…
	â€¢	maxAgeëŠ” JWTì˜ ë§Œë£Œ ì‹œê°„ê³¼ ì¼ì¹˜í•´ì•¼ í•©ë‹ˆë‹¤.
	â€¢	ì¼ì¹˜í•˜ì§€ ì•Šìœ¼ë©´ JWTëŠ” ìœ íš¨í•˜ì§€ë§Œ ì¿ í‚¤ê°€ ì‚­ì œë˜ì–´ ìš”ì²­í•  ìˆ˜ ì—†ëŠ” ë¬¸ì œê°€ ë°œìƒí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

âœ… 6. í”„ë¡ íŠ¸ì—”ë“œ ì²˜ë¦¬ (React)

ğŸ“ Axios Interceptorë¡œ 401 ì—ëŸ¬ ì²˜ë¦¬

import axios from 'axios';

axios.defaults.withCredentials = true;

// Axios Interceptor
axios.interceptors.response.use(
    response => response,
    error => {
        if (error.response && error.response.status === 401) {
            if (error.response.data.error === "TOKEN_MISSING") {
                console.warn('Token missing, redirecting to login...');
            } else if (error.response.data.error === "TOKEN_EXPIRED") {
                console.warn('Token expired, redirecting to re-authenticate...');
            }
            window.location.href = '/oauth/authorize';
        }
        return Promise.reject(error);
    }
);

âœ… 7. ìµœì¢… íë¦„
	1.	Access Token ìœ íš¨:
	â€¢	ìš”ì²­ ì²˜ë¦¬ ì •ìƒ ì‘ë™.
	2.	Access Token ë§Œë£Œ (exp ì§€ë‚¨):
	â€¢	401 Unauthorizedì™€ TOKEN_EXPIRED ì‘ë‹µ.
	â€¢	Reactê°€ /oauth/authorizeë¡œ ë¦¬ë‹¤ì´ë ‰ì…˜.
	3.	ì¿ í‚¤ ë§Œë£Œ:
	â€¢	Access Tokenì´ ì„œë²„ë¡œ ì „ë‹¬ë˜ì§€ ì•ŠìŒ.
	â€¢	401 Unauthorizedì™€ TOKEN_MISSING ì‘ë‹µ.
	â€¢	Reactê°€ /oauth/authorizeë¡œ ë¦¬ë‹¤ì´ë ‰ì…˜.
	4.	ë‹¤ì‹œ Access Codeë¥¼ ìš”ì²­:
	â€¢	ì‚¬ìš©ìëŠ” /oauth/authorizeì—ì„œ Access Codeë¥¼ ë°›ì•„ Access Tokenì„ ì¬ë°œê¸‰.

âœ… 8. ìµœì¢… ì •ë¦¬
	â€¢	Access Token ë§Œë£ŒëŠ” JWTì˜ exp í´ë ˆì„ìœ¼ë¡œ í™•ì¸í•©ë‹ˆë‹¤.
	â€¢	ë¸Œë¼ìš°ì € ì¿ í‚¤ ë§Œë£ŒëŠ” maxAgeë‚˜ Expires ì†ì„±ìœ¼ë¡œ í™•ì¸í•©ë‹ˆë‹¤.
	â€¢	Access Token ë§Œë£Œ: 401 Unauthorizedì™€ TOKEN_EXPIRED ë°˜í™˜.
	â€¢	ì¿ í‚¤ ë§Œë£Œ: 401 Unauthorizedì™€ TOKEN_MISSING ë°˜í™˜.
	â€¢	í”„ë¡ íŠ¸ì—”ë“œì—ì„œ 401 ì‘ë‹µì„ ê°ì§€í•´ /oauth/authorizeë¡œ ë¦¬ë””ë ‰ì…˜.

ì´ì œ Access Tokenê³¼ ì¿ í‚¤ ë§Œë£Œë¥¼ ì•ˆì „í•˜ê²Œ ë‹¤ë£¨ê³  ì¬ì¸ì¦ì„ ìœ ë„í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤! ğŸš€ğŸ”âœ¨










ğŸš€ Access Code ê¸°ë°˜ OAuth 2.0 Flowì—ì„œ Access Token ë§Œë£Œ ì²˜ë¦¬ (Refresh Token ì—†ì´)

ğŸ“š 1. ëª©í‘œ
	1.	Refresh Token ì—†ì´ Access Tokenì´ ë§Œë£Œëœ ê²½ìš°, ì‚¬ìš©ìëŠ” Access Code Flowë¥¼ í†µí•´ ìƒˆ Access Tokenì„ ë°›ì•„ì•¼ í•©ë‹ˆë‹¤.
	2.	Access Token ë§Œë£Œ ì‹œ í´ë¼ì´ì–¸íŠ¸ê°€ Access Codeë¥¼ ë‹¤ì‹œ ìš”ì²­í•˜ë„ë¡ ìœ ë„í•©ë‹ˆë‹¤.
	3.	ë°±ì—”ë“œì™€ í”„ë¡ íŠ¸ì—”ë“œê°€ ì˜¬ë°”ë¥´ê²Œ Access Token ë§Œë£Œë¥¼ ê°ì§€í•˜ê³  ì²˜ë¦¬í•©ë‹ˆë‹¤.

âš™ï¸ 2. Access Code Flow ìš”ì•½
	1.	ì‚¬ìš©ìëŠ” Authorization Serverë¡œ ë¦¬ë””ë ‰ì…˜ë©ë‹ˆë‹¤.
	2.	ì‚¬ìš©ì ì¸ì¦ í›„ Access Codeê°€ ë°œê¸‰ë©ë‹ˆë‹¤.
	3.	í´ë¼ì´ì–¸íŠ¸ëŠ” Access Codeë¥¼ ë°±ì—”ë“œë¡œ ì „ë‹¬í•©ë‹ˆë‹¤.
	4.	ë°±ì—”ë“œëŠ” Access Codeë¥¼ ì‚¬ìš©í•´ Access Tokenì„ ë°œê¸‰ë°›ìŠµë‹ˆë‹¤.
	5.	Access Tokenì´ ë§Œë£Œë˜ë©´ ì‚¬ìš©ìëŠ” ë‹¤ì‹œ Access Codeë¥¼ ìš”ì²­í•´ì•¼ í•©ë‹ˆë‹¤.

ğŸ› ï¸ 3. ë°±ì—”ë“œ ì²˜ë¦¬

âœ… 3.1 JwtAuthenticationFilter ìˆ˜ì •

ğŸ“ JwtAuthenticationFilter.java

import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.web.filter.OncePerRequestFilter;

import javax.servlet.FilterChain;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

public class JwtAuthenticationFilter extends OncePerRequestFilter {

    private final TokenValidator tokenValidator;

    public JwtAuthenticationFilter(TokenValidator tokenValidator) {
        this.tokenValidator = tokenValidator;
    }

    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)
            throws ServletException, IOException {

        String accessToken = extractTokenFromRequest(request);

        if (accessToken != null) {
            try {
                if (!tokenValidator.validateToken(accessToken)) {
                    throw new RuntimeException("Token expired");
                }

                String username = tokenValidator.getUsernameFromToken(accessToken);
                UsernamePasswordAuthenticationToken authentication = 
                    new UsernamePasswordAuthenticationToken(username, null, tokenValidator.getAuthorities(accessToken));

                SecurityContextHolder.getContext().setAuthentication(authentication);
            } catch (Exception e) {
                // âœ… í† í° ë§Œë£Œ ì‹œ 401 ë°˜í™˜ ë° ë¦¬ë””ë ‰ì…˜ ìœ ë„
                response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
                response.getWriter().write("{\"error\":\"TOKEN_EXPIRED\", \"redirect_uri\":\"/oauth/authorize\"}");
                return;
            }
        }

        filterChain.doFilter(request, response);
    }

    private String extractTokenFromRequest(HttpServletRequest request) {
        String bearerToken = request.getHeader("Authorization");
        if (bearerToken != null && bearerToken.startsWith("Bearer ")) {
            return bearerToken.substring(7);
        }
        return null;
    }
}

ğŸ”‘ ì„¤ëª…
	1.	Access Token ê²€ì¦
	â€¢	validateToken ë©”ì„œë“œë¥¼ í†µí•´ í† í° ìœ íš¨ì„± í™•ì¸.
	2.	í† í° ë§Œë£Œ ê°ì§€
	â€¢	í† í°ì´ ë§Œë£Œë˜ë©´ 401 Unauthorized ìƒíƒœ ì½”ë“œ ë°˜í™˜.
	â€¢	JSON ì‘ë‹µìœ¼ë¡œ redirect_urië¥¼ ì „ë‹¬í•´ í”„ë¡ íŠ¸ì—”ë“œê°€ Access Code ìš”ì²­ì„ ìœ ë„í•  ìˆ˜ ìˆê²Œ í•¨.

âœ… 3.2 AuthController

ğŸ“ AuthController.java

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseCookie;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestParam;

import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.util.*;
import java.util.stream.Collectors;

@Controller
public class AuthController {

    @Autowired
    private OAuth2TokenService oAuth2TokenService;

    @Autowired
    private TokenValidator tokenValidator;

    @GetMapping("/handle_redirect")
    public void handleOAuthCallback(
            @RequestParam String code,
            @RequestParam(required = false) String state,
            HttpServletResponse response
    ) throws IOException {
        try {
            if (state == null || !isValidState(state)) {
                response.sendRedirect("/error?message=Invalid state parameter");
                return;
            }

            // Access Code â†’ Access Token êµí™˜
            Map<String, String> tokens = oAuth2TokenService.exchangeAuthorizationCode(code);
            String accessToken = tokens.get("access_token");
            String username = tokenValidator.getUsernameFromToken(accessToken);
            Date expiration = tokenValidator.getExpirationDateFromToken(accessToken);

            // SecurityContext ì €ì¥
            List<String> roles = tokenValidator.getRolesFromToken(accessToken);
            List<GrantedAuthority> authorities = roles.stream()
                    .map(role -> new SimpleGrantedAuthority("ROLE_" + role))
                    .collect(Collectors.toList());

            UsernamePasswordAuthenticationToken authentication =
                    new UsernamePasswordAuthenticationToken(username, null, authorities);
            SecurityContextHolder.getContext().setAuthentication(authentication);

            // HttpOnly ì¿ í‚¤ì— ì €ì¥
            ResponseCookie accessTokenCookie = ResponseCookie.from("access_token", accessToken)
                    .httpOnly(true)
                    .secure(true)
                    .path("/")
                    .maxAge((expiration.getTime() - System.currentTimeMillis()) / 1000)
                    .sameSite("Strict")
                    .build();

            response.addHeader("Set-Cookie", accessTokenCookie.toString());
            response.sendRedirect("/ui");
        } catch (Exception e) {
            response.sendRedirect("/error?message=Failed to handle OAuth2 callback");
        }
    }

    private boolean isValidState(String state) {
        return "expected_state_value".equals(state);
    }
}

âš›ï¸ 4. í”„ë¡ íŠ¸ì—”ë“œ ì²˜ë¦¬ (React)

âœ… 4.1 Axios Interceptor

ğŸ“ AuthService.js

import axios from 'axios';

axios.defaults.withCredentials = true;

// Axios ì¸í„°ì…‰í„°
axios.interceptors.response.use(
    response => response,
    error => {
        if (error.response && error.response.status === 401) {
            const redirectUri = error.response.data?.redirect_uri || '/login';
            console.warn('Token expired, redirecting to re-authenticate...');
            window.location.href = redirectUri;
        }
        return Promise.reject(error);
    }
);

/**
 * API í˜¸ì¶œ ì˜ˆì‹œ
 */
export const fetchProtectedData = async () => {
    try {
        const response = await axios.get('/api/protected');
        return response.data;
    } catch (error) {
        console.error('Failed to fetch protected data:', error);
        throw error;
    }
};

ğŸ”‘ ì„¤ëª…
	1.	401 Unauthorized ê°ì§€
	â€¢	ë§Œë£Œëœ Access Tokenì´ ê°ì§€ë˜ë©´ redirect_urië¡œ ì´ë™.
	2.	Access Code Flow ì¬ì‹œì‘
	â€¢	ì‚¬ìš©ìëŠ” /oauth/authorizeë¡œ ë¦¬ë””ë ‰ì…˜ë˜ì–´ Access Codeë¥¼ ë‹¤ì‹œ ë°›ìŠµë‹ˆë‹¤.

âœ… 4.2 OAuthCallback.js

ğŸ“ OAuthCallback.js

import React, { useEffect } from 'react';
import { useSearchParams, useNavigate } from 'react-router-dom';

function OAuthCallback() {
    const [searchParams] = useSearchParams();
    const navigate = useNavigate();

    useEffect(() => {
        const code = searchParams.get('code');
        if (code) {
            axios.get(`/handle_redirect?code=${code}`)
                .then(() => {
                    navigate('/ui');
                })
                .catch(() => {
                    navigate('/error');
                });
        } else {
            navigate('/error');
        }
    }, [navigate, searchParams]);

    return <div>Authenticating...</div>;
}

âœ… 5. íë¦„ ìš”ì•½
	1.	Access Token ë§Œë£Œ â†’ 401 Unauthorized
	2.	í”„ë¡ íŠ¸ì—”ë“œ Interceptorê°€ ë¦¬ë‹¤ì´ë ‰ì…˜ ìœ ë„
	3.	ì‚¬ìš©ì /oauth/authorizeë¡œ ì´ë™ â†’ Access Code ë°œê¸‰
	4.	Access Code â†’ Access Token êµí™˜
	5.	ìƒˆ Access Tokenìœ¼ë¡œ ë³´í˜¸ëœ ë¦¬ì†ŒìŠ¤ ì ‘ê·¼

ğŸ¯ 6. ìµœì¢… ì •ë¦¬

âœ… Access Token ë§Œë£Œ ê°ì§€ ë° ë¦¬ë””ë ‰ì…˜
âœ… Access Code Flow ì¬ì‹œì‘
âœ… ë³´ì•ˆ ë° ì‚¬ìš©ì ê²½í—˜ ê°œì„ 

ì´ì œ Refresh Token ì—†ì´ Access Token ë§Œë£Œë¥¼ ì•ˆì „í•˜ê³  íš¨ìœ¨ì ìœ¼ë¡œ ì²˜ë¦¬í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤! ğŸš€ğŸ”‘âœ¨






ğŸš€ React + Spring Boot OAuth2 + Test Account í†µí•© ì˜ˆì œ

ğŸ“š 1. í”„ë¡œì íŠ¸ êµ¬ì¡°

âœ… Backend (Spring Boot)

/src/main/java/com/example/security
â”œâ”€â”€ config/
â”‚   â”œâ”€â”€ SecurityConfig.java      // Spring Security ì„¤ì •
â”‚   â”œâ”€â”€ CorsConfig.java          // CORS ì„¤ì •
â”‚   â”œâ”€â”€ JwtTokenUtil.java        // JWT í† í° ìœ í‹¸ë¦¬í‹°
â”‚   â”œâ”€â”€ TokenValidator.java      // JWT í† í° ê²€ì¦
â”œâ”€â”€ controller/
â”‚   â”œâ”€â”€ AuthController.java      // OAuth2 & Test Account ì»¨íŠ¸ë¡¤ëŸ¬
â”œâ”€â”€ oauth2/
â”‚   â”œâ”€â”€ OAuth2TokenService.java  // Authorization Code â†’ Access Token
â”œâ”€â”€ service/
â”‚   â”œâ”€â”€ TestAccountService.java  // Test Account ì¸ì¦ ì„œë¹„ìŠ¤
â”œâ”€â”€ filter/
â”‚   â”œâ”€â”€ JwtAuthenticationFilter.java  // JWT í•„í„°
â””â”€â”€ application.yml              // í™˜ê²½ì„¤ì •

âœ… Frontend (React)

/src
â”œâ”€â”€ index.js
â”œâ”€â”€ App.js
â”œâ”€â”€ routes.js        // ë¼ìš°í„° ì„¤ì •
â”œâ”€â”€ services/
â”‚   â”œâ”€â”€ AuthService.js // ì¸ì¦ ì„œë¹„ìŠ¤
â”œâ”€â”€ pages/
â”‚   â”œâ”€â”€ Login.js       // ë¡œê·¸ì¸ í˜ì´ì§€
â”‚   â”œâ”€â”€ OAuthCallback.js // OAuth ë¦¬ë‹¤ì´ë ‰íŠ¸ ì²˜ë¦¬
â”‚   â”œâ”€â”€ ProtectedResource.js // ë³´í˜¸ëœ í˜ì´ì§€

ğŸ”‘ 2. Backend (Spring Boot)

âœ… 2.1 SecurityConfig.java

package com.example.security.config;

import com.example.security.filter.JwtAuthenticationFilter;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;

@Configuration
public class SecurityConfig {

    private final JwtAuthenticationFilter jwtAuthenticationFilter;

    public SecurityConfig(JwtAuthenticationFilter jwtAuthenticationFilter) {
        this.jwtAuthenticationFilter = jwtAuthenticationFilter;
    }

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
            .cors().and()
            .csrf().disable()
            .authorizeHttpRequests(auth -> auth
                .requestMatchers("/api/oauth/**").permitAll()
                .requestMatchers("/handle_redirect").permitAll()
                .requestMatchers("/api/auth/test-login").permitAll()
                .anyRequest().authenticated()
            )
            .sessionManagement(session -> session
                .sessionCreationPolicy(SessionCreationPolicy.STATELESS)
            )
            .addFilterBefore(jwtAuthenticationFilter, UsernamePasswordAuthenticationFilter.class);

        return http.build();
    }
}

âœ… 2.2 AuthController.java

package com.example.security.controller;

import com.example.security.oauth2.OAuth2TokenService;
import com.example.security.jwt.TokenValidator;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.web.bind.annotation.*;

import javax.servlet.http.HttpServletRequest;
import java.util.Collections;
import java.util.Map;

@RestController
@RequestMapping("/api/auth")
public class AuthController {

    @Autowired
    private OAuth2TokenService oAuth2TokenService;

    @Autowired
    private TokenValidator tokenValidator;

    @PostMapping("/handle_redirect")
    public ResponseEntity<Map<String, String>> handleOAuthCallback(@RequestParam String code, HttpServletRequest request) {
        Map<String, String> tokens = oAuth2TokenService.exchangeAuthorizationCode(code);
        String accessToken = tokens.get("access_token");
        String username = tokenValidator.getUsernameFromToken(accessToken);
        String role = tokenValidator.getRoleFromToken(accessToken);

        UsernamePasswordAuthenticationToken authentication = new UsernamePasswordAuthenticationToken(
                username, null, Collections.singleton(() -> "ROLE_" + role)
        );
        SecurityContextHolder.getContext().setAuthentication(authentication);

        return ResponseEntity.ok(Map.of(
                "accessToken", accessToken,
                "username", username,
                "role", role
        ));
    }

    @PostMapping("/test-login")
    public ResponseEntity<Map<String, String>> testLogin(@RequestParam String username, @RequestParam String password) {
        if ("testUser".equals(username) && "password123".equals(password)) {
            String accessToken = "testAccessToken";
            return ResponseEntity.ok(Map.of(
                    "accessToken", accessToken,
                    "username", username,
                    "role", "USER"
            ));
        }
        return ResponseEntity.badRequest().body(Map.of("error", "Invalid credentials"));
    }
}

âœ… 2.3 OAuth2TokenService.java

package com.example.security.oauth2;

import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;

import java.util.Map;

@Service
public class OAuth2TokenService {

    public Map<String, String> exchangeAuthorizationCode(String code) {
        RestTemplate restTemplate = new RestTemplate();

        Map<String, String> request = Map.of(
                "grant_type", "authorization_code",
                "code", code,
                "redirect_uri", "https://localhost:8080/handle_redirect",
                "client_id", "your-client-id",
                "client_secret", "your-client-secret"
        );

        Map response = restTemplate.postForObject("https://idanywhere.com/oauth/token", request, Map.class);
        return Map.of(
                "access_token", response.get("access_token").toString()
        );
    }
}

âš›ï¸ 3. Frontend (React)

âœ… 3.1 routes.js

import { createBrowserRouter, RouterProvider } from 'react-router-dom';
import Login from './pages/Login';
import OAuthCallback from './pages/OAuthCallback';
import ProtectedResource from './pages/ProtectedResource';

const router = createBrowserRouter([
    { path: '/', element: <Login /> },
    { path: '/handle_redirect', element: <OAuthCallback /> },
    { path: '/protected', element: <ProtectedResource /> },
]);

export default router;

âœ… 3.2 Login.js

import React, { useState } from 'react';
import { testLogin } from '../services/AuthService';

function Login() {
    const [username, setUsername] = useState('');
    const [password, setPassword] = useState('');

    const handleOAuthLogin = () => {
        window.location.href = 'https://idanywhere.com/oauth/authorize?' +
            'client_id=your-client-id&response_type=code&' +
            'redirect_uri=https://localhost:8080/handle_redirect';
    };

    const handleTestLogin = async () => {
        await testLogin(username, password);
        window.location.href = '/protected';
    };

    return (
        <div>
            <button onClick={handleOAuthLogin}>OAuth Login</button>
            <input value={username} onChange={(e) => setUsername(e.target.value)} />
            <input value={password} onChange={(e) => setPassword(e.target.value)} />
            <button onClick={handleTestLogin}>Test Login</button>
        </div>
    );
}

âœ… 3.3 AuthService.js

import axios from 'axios';

export const fetchAccessToken = async (code) => {
    const response = await axios.post(`/api/auth/handle_redirect?code=${code}`);
    localStorage.setItem('accessToken', response.data.accessToken);
};

export const testLogin = async (username, password) => {
    const response = await axios.post('/api/auth/test-login', { username, password });
    localStorage.setItem('accessToken', response.data.accessToken);
};

âœ… 3.4 ProtectedResource.js

import React, { useEffect } from 'react';

function ProtectedResource() {
    useEffect(() => {
        console.log('Access Protected Resource');
    }, []);

    return <div>Protected Resource</div>;
}

ğŸ¯ 4. ìš”ì•½
	1.	âœ… OAuth2 ë¡œê·¸ì¸ (/handle_redirect)
	2.	âœ… Test Account ë¡œê·¸ì¸ (/test-login)
	3.	âœ… JWT í† í° ì¸ì¦
	4.	âœ… React Routerë¡œ í˜ì´ì§€ ê´€ë¦¬

ì´ì œ ì™„ì „í•œ OAuth2 + Test Account + React + Spring Boot í†µí•© í”„ë¡œì íŠ¸ê°€ ì™„ì„±ë˜ì—ˆìŠµë‹ˆë‹¤! ğŸš€ğŸ”







ğŸ”„ Reactì—ì„œ createBrowserRouterë¥¼ ì‚¬ìš©í•˜ì—¬ OAuth2 Redirect ì²˜ë¦¬í•˜ê¸°

ğŸ“š 1. createBrowserRouterë€?
	â€¢	createBrowserRouterëŠ” React Router v6.4 ì´ìƒì—ì„œ ì‚¬ìš©ë˜ëŠ” APIì…ë‹ˆë‹¤.
	â€¢	BrowserRouterë³´ë‹¤ ë” ëª…í™•í•˜ê²Œ ë¼ìš°í„°ë¥¼ ì •ì˜í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
	â€¢	OAuth2 Redirect ì²˜ë¦¬ë¥¼ í¬í•¨í•œ ë³µì¡í•œ ë¼ìš°íŒ… ì„¤ì •ì— ì í•©í•©ë‹ˆë‹¤.

âš›ï¸ 2. í”„ë¡œì íŠ¸ êµ¬ì¡°

/src
â”œâ”€â”€ index.js
â”œâ”€â”€ App.js
â”œâ”€â”€ routes.js   // ë¼ìš°íŒ… ì •ì˜
â”œâ”€â”€ pages/
â”‚   â”œâ”€â”€ Login.js
â”‚   â”œâ”€â”€ OAuthCallback.js
â”‚   â”œâ”€â”€ ProtectedResource.js
â””â”€â”€ services/
    â”œâ”€â”€ AuthService.js

âœ… 3. ë¼ìš°í„° ì„¤ì •

ğŸ“Œ 3.1 routes.js

import { createBrowserRouter, RouterProvider } from 'react-router-dom';
import Login from './pages/Login';
import OAuthCallback from './pages/OAuthCallback';
import ProtectedResource from './pages/ProtectedResource';

const router = createBrowserRouter([
    {
        path: '/',
        element: <Login />,
    },
    {
        path: '/handle_redirect',
        element: <OAuthCallback />,
    },
    {
        path: '/protected',
        element: <ProtectedResource />,
    },
    {
        path: '*',
        element: <div>404 - Page Not Found</div>,
    },
]);

export default router;

ğŸ“Œ 3.2 index.js

import React from 'react';
import ReactDOM from 'react-dom/client';
import { RouterProvider } from 'react-router-dom';
import router from './routes';

ReactDOM.createRoot(document.getElementById('root')).render(
    <React.StrictMode>
        <RouterProvider router={router} />
    </React.StrictMode>
);

âœ… 4. OAuthCallback.js

OAuth2 Redirect ì²˜ë¦¬ ì»´í¬ë„ŒíŠ¸

import React, { useEffect } from 'react';
import { fetchAccessToken } from '../services/AuthService';
import { useNavigate, useSearchParams } from 'react-router-dom';

function OAuthCallback() {
    const [searchParams] = useSearchParams();
    const navigate = useNavigate();

    useEffect(() => {
        const code = searchParams.get('code');
        if (code) {
            fetchAccessToken(code)
                .then(() => {
                    console.log('Access Token successfully fetched');
                    navigate('/protected'); // ì„±ê³µ ì‹œ Protected í˜ì´ì§€ë¡œ ì´ë™
                })
                .catch((error) => {
                    console.error('Failed to fetch access token:', error);
                    navigate('/login'); // ì‹¤íŒ¨ ì‹œ ë¡œê·¸ì¸ í˜ì´ì§€ë¡œ ì´ë™
                });
        } else {
            console.error('Authorization code is missing');
            navigate('/login');
        }
    }, [navigate, searchParams]);

    return (
        <div>
            <h2>Authenticating...</h2>
            <p>Please wait while we process your authentication.</p>
        </div>
    );
}

export default OAuthCallback;

âœ… ì„¤ëª…:
	1.	useSearchParams:
	â€¢	URLì—ì„œ code íŒŒë¼ë¯¸í„°ë¥¼ ì¶”ì¶œí•©ë‹ˆë‹¤.
	2.	fetchAccessToken:
	â€¢	codeë¥¼ ì‚¬ìš©í•˜ì—¬ Access Tokenì„ ìš”ì²­í•©ë‹ˆë‹¤.
	3.	useNavigate:
	â€¢	ìš”ì²­ ì„±ê³µ ì‹œ /protectedë¡œ ì´ë™í•©ë‹ˆë‹¤.
	â€¢	ì‹¤íŒ¨ ì‹œ /loginìœ¼ë¡œ ì´ë™í•©ë‹ˆë‹¤.

âœ… 5. Login.js

OAuth2 ë° Test Account ë¡œê·¸ì¸

import React, { useState } from 'react';
import { testLogin } from '../services/AuthService';

function Login() {
    const [username, setUsername] = useState('');
    const [password, setPassword] = useState('');

    const handleOAuthLogin = () => {
        window.location.href = 'https://idanywhere.com/oauth/authorize?' +
            'client_id=your-client-id&' +
            'response_type=code&' +
            'redirect_uri=https://localhost:8080/handle_redirect';
    };

    const handleTestLogin = async () => {
        if (!username || !password) {
            alert('Please enter username and password');
            return;
        }
        await testLogin(username, password);
        window.location.href = '/protected';
    };

    return (
        <div style={{ padding: '20px' }}>
            <h2>ğŸ” Login</h2>

            {/* âœ… OAuth2 ë¡œê·¸ì¸ ë²„íŠ¼ */}
            <button onClick={handleOAuthLogin} style={{ marginBottom: '10px' }}>
                Login with OAuth2
            </button>

            <hr />

            {/* âœ… Test Account ë¡œê·¸ì¸ */}
            <h3>Test Account Login</h3>
            <input
                type="text"
                placeholder="Username"
                value={username}
                onChange={(e) => setUsername(e.target.value)}
            />
            <br />
            <input
                type="password"
                placeholder="Password"
                value={password}
                onChange={(e) => setPassword(e.target.value)}
            />
            <br />
            <button onClick={handleTestLogin}>Login with Test Account</button>
        </div>
    );
}

export default Login;

âœ… 6. AuthService.js

API í˜¸ì¶œ ë° í† í° ê´€ë¦¬

import axios from 'axios';

export const testLogin = async (username, password) => {
    try {
        const response = await axios.post('/api/auth/test-login', null, {
            params: { username, password },
        });
        const { accessToken, username: user, role } = response.data;
        localStorage.setItem('accessToken', accessToken);
        localStorage.setItem('username', user);
        localStorage.setItem('role', role);
        console.log('Test Account Login Successful');
    } catch (error) {
        console.error('Test Account Login Failed:', error.response?.data || error.message);
    }
};

export const fetchAccessToken = async (code) => {
    try {
        const response = await axios.get(`/api/auth/handle_redirect?code=${code}`);
        const { accessToken, username: user, role } = response.data;
        localStorage.setItem('accessToken', accessToken);
        localStorage.setItem('username', user);
        localStorage.setItem('role', role);
        console.log('OAuth2 Login Successful');
    } catch (error) {
        console.error('OAuth2 Login Failed:', error.response?.data || error.message);
    }
};

export const logout = () => {
    localStorage.removeItem('accessToken');
    localStorage.removeItem('username');
    localStorage.removeItem('role');
    console.log('Logged out successfully');
};

âœ… 7. ProtectedResource.js

import React, { useEffect, useState } from 'react';
import axios from 'axios';

function ProtectedResource() {
    const [data, setData] = useState('');

    useEffect(() => {
        const fetchData = async () => {
            try {
                const accessToken = localStorage.getItem('accessToken');
                const response = await axios.get('/api/user/me', {
                    headers: {
                        Authorization: `Bearer ${accessToken}`,
                    },
                });
                setData(response.data);
            } catch (error) {
                console.error('Failed to fetch resource:', error.response?.data || error.message);
            }
        };

        fetchData();
    }, []);

    return (
        <div>
            <h2>Protected Resource</h2>
            <p>{data}</p>
        </div>
    );
}

export default ProtectedResource;

ğŸ¯ 8. ìµœì¢… ìš”ì•½
	1.	âœ… OAuth2 + Test Account í†µí•© ë¡œê·¸ì¸ ì§€ì›
	2.	âœ… createBrowserRouterë¡œ ëª…í™•í•œ ë¼ìš°íŒ…
	3.	âœ… useEffectë¡œ Redirect ì²˜ë¦¬
	4.	âœ… Access Token ê´€ë¦¬ ë° API ìš”ì²­ ì§€ì›

ì´ì œ createBrowserRouterì™€ í•¨ê»˜ OAuth2 + Test Account í†µí•© ì¸ì¦ì´ ì™„ë²½í•˜ê²Œ ì„¤ì •ë˜ì—ˆìŠµë‹ˆë‹¤! ğŸš€ğŸ”‘






ğŸ”‘ React: OAuth2 + Test Account í†µí•© ë¡œê·¸ì¸ ì˜ˆì œ

ğŸ“š 1. ëª©í‘œ
	1.	OAuth2 ë¡œê·¸ì¸
	â€¢	Authorization Code â†’ Access Token
	2.	Test Account ë¡œê·¸ì¸
	â€¢	Username + Password â†’ Access Token
	3.	Access Token ì €ì¥ ë° API ìš”ì²­ ì‹œ ì‚¬ìš©
	4.	Role ê¸°ë°˜ ì ‘ê·¼ ì œì–´

âš›ï¸ 2. AuthService.js

API í˜¸ì¶œ ë° Token ê´€ë¦¬

import axios from 'axios';

// âœ… Test Account ë¡œê·¸ì¸
export const testLogin = async (username, password) => {
    try {
        const response = await axios.post('/api/auth/test-login', null, {
            params: { username, password },
        });
        const { accessToken, username: user, role } = response.data;
        localStorage.setItem('accessToken', accessToken);
        localStorage.setItem('username', user);
        localStorage.setItem('role', role);
        console.log('Test Account Login Successful');
    } catch (error) {
        console.error('Test Account Login Failed:', error.response?.data || error.message);
    }
};

// âœ… OAuth2 Access Token ìš”ì²­
export const fetchAccessToken = async (code) => {
    try {
        const response = await axios.get(`/api/auth/handle_redirect?code=${code}`);
        const { accessToken, username: user, role } = response.data;
        localStorage.setItem('accessToken', accessToken);
        localStorage.setItem('username', user);
        localStorage.setItem('role', role);
        console.log('OAuth2 Login Successful');
    } catch (error) {
        console.error('OAuth2 Login Failed:', error.response?.data || error.message);
    }
};

// âœ… API ìš”ì²­ (Access Token í¬í•¨)
export const fetchProtectedResource = async () => {
    try {
        const accessToken = localStorage.getItem('accessToken');
        const response = await axios.get('/api/user/me', {
            headers: {
                Authorization: `Bearer ${accessToken}`,
            },
        });
        console.log('Protected Resource:', response.data);
    } catch (error) {
        console.error('Failed to fetch protected resource:', error.response?.data || error.message);
    }
};

// âœ… ë¡œê·¸ì•„ì›ƒ
export const logout = () => {
    localStorage.removeItem('accessToken');
    localStorage.removeItem('username');
    localStorage.removeItem('role');
    console.log('Logged out successfully');
};

âš›ï¸ 3. Login.js

OAuth2 ë° Test Account ë¡œê·¸ì¸ UI

import React, { useEffect, useState } from 'react';
import { testLogin, fetchAccessToken, fetchProtectedResource, logout } from './AuthService';

function Login() {
    const [username, setUsername] = useState('');
    const [password, setPassword] = useState('');
    const [isAuthenticated, setIsAuthenticated] = useState(false);

    // âœ… OAuth2 ë¡œê·¸ì¸ í•¸ë“¤ëŸ¬
    const handleOAuthLogin = () => {
        window.location.href = 'https://idanywhere.com/oauth/authorize?' +
            'client_id=your-client-id&' +
            'response_type=code&' +
            'redirect_uri=https://localhost:8080/handle_redirect';
    };

    // âœ… Test Account ë¡œê·¸ì¸ í•¸ë“¤ëŸ¬
    const handleTestLogin = async () => {
        if (!username || !password) {
            alert('Please enter username and password');
            return;
        }
        await testLogin(username, password);
        setIsAuthenticated(true);
    };

    // âœ… OAuth2 Callback ì²˜ë¦¬
    useEffect(() => {
        const query = new URLSearchParams(window.location.search);
        const code = query.get('code');
        if (code) {
            fetchAccessToken(code).then(() => {
                setIsAuthenticated(true);
                window.history.replaceState({}, document.title, window.location.pathname);
            });
        }
    }, []);

    return (
        <div style={{ padding: '20px' }}>
            <h2>ğŸ” Login</h2>

            {/* âœ… OAuth2 ë¡œê·¸ì¸ ë²„íŠ¼ */}
            <button onClick={handleOAuthLogin} style={{ marginBottom: '10px' }}>
                Login with OAuth2
            </button>

            <hr />

            {/* âœ… Test Account ë¡œê·¸ì¸ */}
            <h3>Test Account Login</h3>
            <input
                type="text"
                placeholder="Username"
                value={username}
                onChange={(e) => setUsername(e.target.value)}
            />
            <br />
            <input
                type="password"
                placeholder="Password"
                value={password}
                onChange={(e) => setPassword(e.target.value)}
            />
            <br />
            <button onClick={handleTestLogin}>Login with Test Account</button>

            <hr />

            {/* âœ… ì¸ì¦ëœ ì‚¬ìš©ì ì •ë³´ í™•ì¸ */}
            {isAuthenticated && (
                <div>
                    <h3>âœ… Authenticated</h3>
                    <button onClick={fetchProtectedResource}>Fetch Protected Resource</button>
                    <br />
                    <button onClick={logout}>Logout</button>
                </div>
            )}
        </div>
    );
}

export default Login;

âš›ï¸ 4. ProtectedResource.js

ì¸ì¦ëœ ì‚¬ìš©ì ë°ì´í„° í™•ì¸

import React, { useEffect, useState } from 'react';
import axios from 'axios';

function ProtectedResource() {
    const [data, setData] = useState('');

    useEffect(() => {
        const fetchData = async () => {
            try {
                const accessToken = localStorage.getItem('accessToken');
                const response = await axios.get('/api/user/me', {
                    headers: {
                        Authorization: `Bearer ${accessToken}`,
                    },
                });
                setData(response.data);
            } catch (error) {
                console.error('Failed to fetch resource:', error.response?.data || error.message);
            }
        };

        fetchData();
    }, []);

    return (
        <div>
            <h2>Protected Resource</h2>
            <p>{data}</p>
        </div>
    );
}

export default ProtectedResource;

ğŸ›¡ï¸ 5. API ìš”ì²­ íë¦„
	1.	OAuth2 ë¡œê·¸ì¸:
	â€¢	ì‚¬ìš©ìëŠ” OAuth2 Providerë¥¼ í†µí•´ Authorization Codeë¥¼ ì–»ìŠµë‹ˆë‹¤.
	â€¢	ë°±ì—”ë“œê°€ Access Tokenì„ ê°€ì ¸ì˜¤ê³ , ì‚¬ìš©ì ì •ë³´ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.
	2.	Test Account ë¡œê·¸ì¸:
	â€¢	ì‚¬ìš©ìëŠ” usernameê³¼ passwordë¥¼ ì…ë ¥í•©ë‹ˆë‹¤.
	â€¢	ë°±ì—”ë“œê°€ ì‚¬ìš©ìë¥¼ ê²€ì¦í•˜ê³  Access Tokenì„ ë°˜í™˜í•©ë‹ˆë‹¤.
	3.	Access Token ì €ì¥:
	â€¢	Access Tokenì€ localStorageì— ì €ì¥ë©ë‹ˆë‹¤.
	â€¢	API ìš”ì²­ ì‹œ Authorization: Bearer <Token> í—¤ë”ì— í¬í•¨ë©ë‹ˆë‹¤.
	4.	Protected API ìš”ì²­:
	â€¢	ì¸ì¦ëœ ì‚¬ìš©ìëŠ” APIë¥¼ í˜¸ì¶œí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

ğŸ¯ 6. ìµœì¢… ìš”ì•½
	1.	OAuth2 ë¡œê·¸ì¸: Authorization Code â†’ Access Token
	2.	Test Account ë¡œê·¸ì¸: Username/Password â†’ Access Token
	3.	Reactì—ì„œ Access Token ê´€ë¦¬: localStorage ì‚¬ìš©
	4.	Protected API ìš”ì²­: Access Token í¬í•¨í•˜ì—¬ ìš”ì²­
	5.	ë¡œê·¸ì•„ì›ƒ ê¸°ëŠ¥ ì§€ì›: localStorageì—ì„œ Token ì œê±°

ğŸš€ 7. ê¶Œì¥ ì‚¬ìš©
	1.	OAuth2: ì‹¤ì‚¬ìš©ì ì¸ì¦ì— ì‚¬ìš©
	2.	Test Account: ê°œë°œ ë° í…ŒìŠ¤íŠ¸ í™˜ê²½ì—ì„œë§Œ ì‚¬ìš©

ì´ì œ OAuth2 ë¡œê·¸ì¸ê³¼ Test Account ë¡œê·¸ì¸ì´ í†µí•©ëœ React ì•±ì´ ì™„ì„±ë˜ì—ˆìŠµë‹ˆë‹¤! ğŸ‰ğŸ”





public class LibraryWrapper {

    // ìŠ¤ë ˆë“œë³„ë¡œ ë…ë¦½ì ì¸ ìƒíƒœë¥¼ ìœ ì§€í•˜ê¸° ìœ„í•´ ThreadLocal ì‚¬ìš©
    private static final ThreadLocal<LibraryWrapper> threadLocalWrapper =
        ThreadLocal.withInitial(LibraryWrapper::new);

    // ë¼ì´ë¸ŒëŸ¬ë¦¬ ì‹±ê¸€í†¤ ì¸ìŠ¤í„´ìŠ¤
    private final LibrarySingleton libraryInstance;

    // ê° ìŠ¤ë ˆë“œë³„ ë…ë¦½ì ì¸ ìƒíƒœ
    private String customState;

    private LibraryWrapper() {
        this.libraryInstance = LibrarySingleton.getInstance(); // ì‹±ê¸€í†¤ ì¸ìŠ¤í„´ìŠ¤ ì°¸ì¡°
        this.customState = "default"; // ì´ˆê¸° ìƒíƒœ ì„¤ì •
    }

    public static LibraryWrapper getInstance() {
        return threadLocalWrapper.get();
    }

    // ìŠ¤ë ˆë“œë³„ë¡œ ë…ë¦½ì ì¸ ìƒíƒœë¥¼ ì„¤ì •í•˜ëŠ” ë©”ì„œë“œ
    public void setCustomState(String state) {
        this.customState = state;
    }

    // ìŠ¤ë ˆë“œë³„ë¡œ ë…ë¦½ì ì¸ ìƒíƒœë¥¼ ì‚¬ìš©í•˜ëŠ” ë©”ì„œë“œ
    public void performActionWithState() {
        System.out.println("Custom State: " + customState);
        libraryInstance.performAction();
    }
}





í˜„ì¬ ì œê³µëœ ì½”ë“œëŠ” ì—‘ì„¸ìŠ¤ í† í°ì„ ë°œê¸‰ë°›ê³ , í•´ë‹¹ í† í°ì„ API ìš”ì²­ì— ì‚¬ìš©í•˜ëŠ” êµ¬ì¡°ë¡œ ë˜ì–´ ìˆì§€ë§Œ, í† í°ì´ í•œ ì‹œê°„ ë™ì•ˆ ìœ ì§€ë˜ë„ë¡ ê´€ë¦¬í•˜ê±°ë‚˜ ë§Œë£Œ ì‹œ ìë™ìœ¼ë¡œ ê°±ì‹ í•˜ëŠ” ê¸°ëŠ¥ì€ í¬í•¨ë˜ì–´ ìˆì§€ ì•ŠìŠµë‹ˆë‹¤. ë§Œì•½ ì—‘ì„¸ìŠ¤ í† í°ì´ í•œ ì‹œê°„ í›„ ë§Œë£Œë˜ëŠ” êµ¬ì¡°ë¼ë©´, í† í°ì˜ ë§Œë£Œ ì‹œê°„ì„ í™•ì¸í•˜ê³ , ë§Œë£Œë˜ì—ˆì„ ë•Œ ë‹¤ì‹œ ë°œê¸‰ë°›ëŠ” ë¡œì§ì´ í•„ìš”í•©ë‹ˆë‹¤.

ì´ë¥¼ ìœ„í•´ í† í°ì„ ìºì‹œí•˜ì—¬ í•œ ì‹œê°„ ë™ì•ˆ ì¬ì‚¬ìš©í•˜ê³ , ë§Œë£Œ ì‹œê°„ì´ ì§€ë‚˜ë©´ í† í°ì„ ìë™ìœ¼ë¡œ ê°±ì‹ í•˜ëŠ” ë°©ì‹ìœ¼ë¡œ êµ¬í˜„í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

1. í† í° ìºì‹± ë° ë§Œë£Œ ê´€ë¦¬ ë¡œì§ ì¶”ê°€

TokenServiceì—ì„œ í† í° ë°œê¸‰ í›„, ìœ íš¨ ì‹œê°„(1ì‹œê°„) ë™ì•ˆ ìºì‹±í•˜ê³ , í† í°ì´ ë§Œë£Œë˜ì—ˆì„ ë•Œë§Œ ë‹¤ì‹œ ìš”ì²­í•˜ì—¬ í† í°ì„ ë°œê¸‰ë°›ë„ë¡ ë³€ê²½í•©ë‹ˆë‹¤.

ìˆ˜ì •ëœ CachedTokenService:

import org.springframework.stereotype.Service;

import java.time.Instant;

@Service
public class CachedTokenService {

    private final TokenService tokenService;

    // í† í° ë° ë§Œë£Œ ì‹œê°„ ê´€ë¦¬
    private String cachedToken;
    private Instant tokenExpiryTime;

    public CachedTokenService(TokenService tokenService) {
        this.tokenService = tokenService;
    }

    // í† í°ì„ ê°€ì ¸ì˜¤ë©°, ë§Œë£Œëœ ê²½ìš° ìƒˆë¡œìš´ í† í° ë°œê¸‰
    public String getAccessToken(String clientId, String clientSecret, String tokenUrl) {
        // í† í°ì´ ì—†ê±°ë‚˜ ë§Œë£Œë˜ì—ˆìœ¼ë©´ ìƒˆë¡œ ë°œê¸‰
        if (cachedToken == null || Instant.now().isAfter(tokenExpiryTime)) {
            cachedToken = tokenService.fetchAccessToken(clientId, clientSecret, tokenUrl);
            // í† í° ë°œê¸‰ í›„ 1ì‹œê°„ ë’¤ì— ë§Œë£Œ ì„¤ì •
            tokenExpiryTime = Instant.now().plusSeconds(3600);  // 1ì‹œê°„ = 3600ì´ˆ
        }
        return cachedToken;
    }
}

2. RestTemplateConfigì—ì„œ ìºì‹±ëœ í† í° ì‚¬ìš©

RestTemplateConfigëŠ” CachedTokenServiceë¥¼ ì‚¬ìš©í•˜ì—¬ ìºì‹±ëœ í† í°ì„ ê°€ì ¸ì˜¤ê³ , í† í°ì´ ë§Œë£Œë˜ì—ˆì„ ê²½ìš° ìƒˆë¡œìš´ í† í°ì„ ë°œê¸‰ë°›ì•„ RestTemplateì„ ë¦¬í„´í•˜ëŠ” ë°©ì‹ìœ¼ë¡œ ë³€ê²½í•©ë‹ˆë‹¤.

ìˆ˜ì •ëœ RestTemplateConfig:

import org.springframework.boot.web.client.RestTemplateBuilder;
import org.springframework.context.annotation.Bean;
import org.springframework.http.HttpHeaders;
import org.springframework.http.client.ClientHttpRequestInterceptor;
import org.springframework.stereotype.Component;
import org.springframework.web.client.RestTemplate;

@Component
public class RestTemplateConfig {

    private final CachedTokenService cachedTokenService;

    public RestTemplateConfig(CachedTokenService cachedTokenService) {
        this.cachedTokenService = cachedTokenService;
    }

    // ë™ì ìœ¼ë¡œ clientId, tokenUrlì— ë§ëŠ” RestTemplate ë¦¬í„´
    public RestTemplate createRestTemplate(String clientId, String clientSecret, String tokenUrl) {
        String accessToken = cachedTokenService.getAccessToken(clientId, clientSecret, tokenUrl);  // ìºì‹±ëœ í† í° ì‚¬ìš©

        // í† í°ì„ í¬í•¨í•˜ëŠ” ì¸í„°ì…‰í„° ì„¤ì •
        ClientHttpRequestInterceptor interceptor = (request, body, execution) -> {
            request.getHeaders().add(HttpHeaders.AUTHORIZATION, "Bearer " + accessToken);  // í† í° ì¶”ê°€
            return execution.execute(request, body);
        };

        // RestTemplateBuilderë¡œ ì„¤ì •ëœ RestTemplate ë°˜í™˜
        return new RestTemplateBuilder()
                .additionalInterceptors(interceptor)
                .build();
    }
}

3. ì„œë¹„ìŠ¤ì—ì„œ ìºì‹±ëœ í† í°ì„ ì´ìš©í•œ API í˜¸ì¶œ

ì´ì œ API í˜¸ì¶œ ì‹œ RestTemplateConfigì—ì„œ ìºì‹±ëœ í† í°ì„ ì‚¬ìš©í•˜ì—¬ ìš”ì²­ì„ ë³´ëƒ…ë‹ˆë‹¤. ìš”ì²­ ì‹œ í† í°ì´ ë§Œë£Œë˜ì—ˆìœ¼ë©´ ìë™ìœ¼ë¡œ ê°±ì‹ ë˜ì–´ ìƒˆë¡œìš´ í† í°ì„ ì‚¬ìš©í•©ë‹ˆë‹¤.

ìˆ˜ì •ëœ ApiService:

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;

@Service
public class ApiService {

    private final RestTemplateConfig restTemplateConfig;

    @Autowired
    public ApiService(RestTemplateConfig restTemplateConfig) {
        this.restTemplateConfig = restTemplateConfig;
    }

    public String callExternalApi(String clientId, String clientSecret, String tokenUrl, String apiUrl) {
        // ìºì‹±ëœ í† í°ì„ ì‚¬ìš©í•˜ëŠ” RestTemplate ìƒì„±
        RestTemplate restTemplate = restTemplateConfig.createRestTemplate(clientId, clientSecret, tokenUrl);

        // GET ìš”ì²­ì„ ë³´ë‚´ê³ , ì‘ë‹µ ë°›ê¸°
        ResponseEntity<String> response = restTemplate.getForEntity(apiUrl, String.class);

        if (response.getStatusCode().is2xxSuccessful()) {
            return response.getBody();  // ì„±ê³µí•˜ë©´ ì‘ë‹µ ë³¸ë¬¸ ë°˜í™˜
        } else {
            return "Failed with status: " + response.getStatusCode();
        }
    }
}

4. ë™ì‘ íë¦„

	1.	CachedTokenService:
	â€¢	ì—‘ì„¸ìŠ¤ í† í°ì´ ë°œê¸‰ë˜ë©´, í•´ë‹¹ í† í°ì€ 1ì‹œê°„ ë™ì•ˆ ìºì‹œë©ë‹ˆë‹¤.
	â€¢	1ì‹œê°„ì´ ì§€ë‚˜ë©´ í† í°ì´ ë§Œë£Œë˜ê³ , ìƒˆë¡œìš´ í† í°ì„ ë°œê¸‰ë°›ìŠµë‹ˆë‹¤.
	2.	RestTemplateConfig:
	â€¢	RestTemplateì„ ìƒì„±í•  ë•Œ CachedTokenServiceì—ì„œ ìºì‹±ëœ í† í°ì„ ê°€ì ¸ì™€ Authorization í—¤ë”ì— ì¶”ê°€í•©ë‹ˆë‹¤.
	3.	ApiService:
	â€¢	RestTemplateConfigì—ì„œ í† í°ì´ í¬í•¨ëœ RestTemplateì„ ê°€ì ¸ì™€ API ìš”ì²­ì„ ì²˜ë¦¬í•©ë‹ˆë‹¤.

ê²°ë¡ :

	â€¢	ì´ êµ¬ì¡°ì—ì„œëŠ” ì—‘ì„¸ìŠ¤ í† í°ì´ 1ì‹œê°„ ë™ì•ˆ ìœ ì§€ë©ë‹ˆë‹¤.
	â€¢	í† í°ì´ ë§Œë£Œë˜ë©´ ìë™ìœ¼ë¡œ ìƒˆë¡œìš´ í† í°ì„ ë°œê¸‰ë°›ì•„ API ìš”ì²­ì— ì‚¬ìš©í•©ë‹ˆë‹¤.
	â€¢	ì´ë ‡ê²Œ í•˜ë©´ 1ì‹œê°„ ì´ë‚´ì—ëŠ” ë°œê¸‰ë°›ì€ í† í°ì„ ê³„ì† ì‚¬ìš©í•˜ê³ , ê·¸ ì´í›„ì—ëŠ” ìë™ìœ¼ë¡œ ê°±ì‹ ëœ í† í°ì„ ì‚¬ìš©í•˜ê²Œ ë©ë‹ˆë‹¤.

ì´ë¥¼ í†µí•´ ì—‘ì„¸ìŠ¤ í† í°ì„ íš¨ìœ¨ì ìœ¼ë¡œ ê´€ë¦¬í•  ìˆ˜ ìˆìœ¼ë©°, ë§¤ë²ˆ API ìš”ì²­ ì‹œë§ˆë‹¤ ìƒˆë¡œìš´ í† í°ì„ ë°œê¸‰ë°›ì„ í•„ìš” ì—†ì´ ìºì‹±ëœ í† í°ì„ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.







í˜„ì¬ ì œê³µëœ ì½”ë“œëŠ” í•œ ì‹œê°„ ë°˜(90ë¶„)ì´ ì§€ë‚˜ë©´ ìƒˆë¡œìš´ ì—‘ì„¸ìŠ¤ í† í°ì„ ìë™ìœ¼ë¡œ ë°›ì•„ì˜¤ë„ë¡ ì„¤ê³„ë˜ì–´ ìˆìŠµë‹ˆë‹¤. ê·¸ëŸ¬ë‚˜ ì—ëŸ¬ê°€ ë°œìƒí–ˆì„ ë•Œë„ í† í°ì„ ê°±ì‹ í•  ìˆ˜ ìˆë„ë¡ ì¶”ê°€ì ì¸ ë¡œì§ì„ êµ¬í˜„í•˜ëŠ” ê²ƒì´ í•„ìš”í•©ë‹ˆë‹¤. ì¼ë°˜ì ìœ¼ë¡œ API ì„œë²„ì—ì„œ ì—‘ì„¸ìŠ¤ í† í° ë§Œë£Œ ì‹œ â€œ401 Unauthorizedâ€ì™€ ê°™ì€ ìƒíƒœ ì½”ë“œê°€ ë°˜í™˜ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì´ ê²½ìš°ì— í† í°ì„ ì¬ë°œê¸‰í•˜ê³ , ë‹¤ì‹œ ìš”ì²­ì„ ì‹œë„í•˜ëŠ” ë¡œì§ì„ ì¶”ê°€í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import org.springframework.http.ResponseEntity;
import org.springframework.util.LinkedMultiValueMap;
import org.springframework.util.MultiValueMap;

@Service
public class TokenService {
    
    private static final String TOKEN_URL = "https://thirdparty.com/oauth/token";

    // ì—‘ì„¸ìŠ¤ í† í°ì„ ë°›ì•„ì˜¤ëŠ” ë©”ì†Œë“œ
    public String fetchAccessToken() {
        RestTemplate restTemplate = new RestTemplate();

        // í¼ ë°ì´í„° ì„¤ì •
        MultiValueMap<String, String> requestData = new LinkedMultiValueMap<>();
        requestData.add("grant_type", "client_credentials");
        requestData.add("client_id", "your_client_id");
        requestData.add("client_secret", "your_client_secret");

        // POST ìš”ì²­ìœ¼ë¡œ í† í° ê°€ì ¸ì˜¤ê¸°
        ResponseEntity<TokenResponse> response = restTemplate.postForEntity(TOKEN_URL, requestData, TokenResponse.class);
        
        return response.getBody().getAccessToken(); // í† í°ì„ ë°˜í™˜
    }

    // ì‘ë‹µ ë°ì´í„°ë¥¼ ë‹´ì„ í´ë˜ìŠ¤
    public static class TokenResponse {
        private String access_token;

        public String getAccessToken() {
            return access_token;
        }

        public void setAccessToken(String access_token) {
            this.access_token = access_token;
        }
    }
}









ì´ë¥¼ ìœ„í•´ RestTemplateì— ì¬ì‹œë„ ë¡œì§ì„ ì¶”ê°€í•˜ê³ , 401 ìƒíƒœ ì½”ë“œê°€ ë°œìƒí–ˆì„ ë•Œ ì—‘ì„¸ìŠ¤ í† í°ì„ ê°±ì‹ í•˜ëŠ” ë°©ì‹ì„ ì ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

ìˆ˜ì •ëœ ë¡œì§ (401 ì—ëŸ¬ ì‹œ í† í° ê°±ì‹  ë° ì¬ì‹œë„)

	1.	í† í° ê°±ì‹  ì¸í„°ì…‰í„° ì‘ì„±:
	â€¢	ìš”ì²­ì´ ì‹¤íŒ¨í•˜ê³  401 ì—ëŸ¬ê°€ ë°œìƒí•˜ë©´ í† í°ì„ ìƒˆë¡œ ë°›ì•„ì˜¤ê³ , ë‹¤ì‹œ ìš”ì²­ì„ ì‹œë„í•˜ëŠ” ë¡œì§ì„ êµ¬í˜„í•©ë‹ˆë‹¤.
	2.	RestTemplateBuilderì— ì¸í„°ì…‰í„° ì ìš©**:
	â€¢	ClientHttpRequestInterceptorë¥¼ ì‚¬ìš©í•˜ì—¬ ì¬ì‹œë„ ë¡œì§ì„ ì¶”ê°€í•©ë‹ˆë‹¤.

êµ¬í˜„ ì½”ë“œ:

import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpMethod;
import org.springframework.http.HttpRequest;
import org.springframework.http.client.ClientHttpRequestExecution;
import org.springframework.http.client.ClientHttpRequestInterceptor;
import org.springframework.http.client.ClientHttpResponse;
import org.springframework.stereotype.Component;
import org.springframework.web.client.RestTemplate;

import java.io.IOException;

@Component
public class RetryableTokenInterceptor implements ClientHttpRequestInterceptor {

    private final CachedTokenService cachedTokenService;

    public RetryableTokenInterceptor(CachedTokenService cachedTokenService) {
        this.cachedTokenService = cachedTokenService;
    }

    @Override
    public ClientHttpResponse intercept(HttpRequest request, byte[] body, ClientHttpRequestExecution execution) throws IOException {
        // ì—‘ì„¸ìŠ¤ í† í°ì„ í—¤ë”ì— ì¶”ê°€
        String accessToken = cachedTokenService.getAccessToken();
        request.getHeaders().add("Authorization", "Bearer " + accessToken);

        // ìš”ì²­ì„ ì‹¤í–‰
        ClientHttpResponse response = execution.execute(request, body);

        // 401 ìƒíƒœ ì½”ë“œì¸ ê²½ìš° í† í° ê°±ì‹  ë° ì¬ì‹œë„ ë¡œì§
        if (response.getStatusCode().value() == 401) {
            // ìƒˆë¡œìš´ í† í° ìš”ì²­
            String newAccessToken = cachedTokenService.getAccessToken(true); // ê°•ì œë¡œ í† í° ê°±ì‹ 

            // ê¸°ì¡´ ìš”ì²­ì— ìƒˆë¡œìš´ í† í°ì„ ì¶”ê°€í•˜ì—¬ ë‹¤ì‹œ ì‹¤í–‰
            request.getHeaders().remove("Authorization");
            request.getHeaders().add("Authorization", "Bearer " + newAccessToken);

            // ì¬ì‹œë„
            response = execution.execute(request, body);
        }

        return response;
    }
}

ìˆ˜ì •ëœ CachedTokenService í´ë˜ìŠ¤ (ê°•ì œ í† í° ê°±ì‹  ë¡œì§ í¬í•¨)

import org.springframework.stereotype.Service;

import java.time.Instant;

@Service
public class CachedTokenService {

    private final TokenService tokenService;

    private Instant tokenExpiryTime;
    private String cachedToken;

    public CachedTokenService(TokenService tokenService) {
        this.tokenService = tokenService;
    }

    // í† í° ë§Œë£Œ ì‹œê°„ í™•ì¸ ë° ê°±ì‹  (forceRenew = trueë©´ ê°•ì œ ê°±ì‹ )
    public String getAccessToken() {
        return getAccessToken(false);
    }

    public String getAccessToken(boolean forceRenew) {
        if (forceRenew || cachedToken == null || Instant.now().isAfter(tokenExpiryTime)) {
            cachedToken = tokenService.fetchAccessToken();
            // í† í° ë°œê¸‰ í›„ 90ë¶„ ë™ì•ˆ ìœ íš¨
            tokenExpiryTime = Instant.now().plusSeconds(90 * 60);
        }
        return cachedToken;
    }
}

RestTemplate ì„¤ì •ì— ì¸í„°ì…‰í„° ì¶”ê°€

import org.springframework.boot.web.client.RestTemplateBuilder;
import org.springframework.context.annotation.Bean;
import org.springframework.stereotype.Component;
import org.springframework.web.client.RestTemplate;

import java.time.Duration;

@Component
public class RestTemplateConfig {

    private final RetryableTokenInterceptor retryableTokenInterceptor;

    public RestTemplateConfig(RetryableTokenInterceptor retryableTokenInterceptor) {
        this.retryableTokenInterceptor = retryableTokenInterceptor;
    }

    @Bean
    public RestTemplate restTemplate(RestTemplateBuilder builder) {
        return builder
                .setConnectTimeout(Duration.ofSeconds(30))
                .setReadTimeout(Duration.ofSeconds(30))
                .additionalInterceptors(retryableTokenInterceptor)
                .build();
    }
}

ì„¤ëª…:

	1.	RetryableTokenInterceptor: ì´ ì¸í„°ì…‰í„°ëŠ” HTTP ìš”ì²­ì„ ë³´ë‚´ê¸° ì „ Authorization í—¤ë”ì— ì—‘ì„¸ìŠ¤ í† í°ì„ ì¶”ê°€í•˜ê³ , ì„œë²„ ì‘ë‹µì´ 401 (Unauthorized) ì¼ ê²½ìš° ì—‘ì„¸ìŠ¤ í† í°ì„ ìƒˆë¡œ ë°œê¸‰ë°›ì•„ ìš”ì²­ì„ ì¬ì‹œë„í•˜ëŠ” ë¡œì§ì„ í¬í•¨í•©ë‹ˆë‹¤.
	â€¢	í† í° ê°±ì‹  ë° ì¬ì‹œë„: ìš”ì²­ì´ 401 ì˜¤ë¥˜ë¥¼ ë°˜í™˜í•˜ë©´, ìƒˆë¡œìš´ í† í°ì„ ë°œê¸‰ë°›ê³  ì›ë˜ ìš”ì²­ì„ ì¬ì‹œë„í•©ë‹ˆë‹¤.
	2.	CachedTokenService:
	â€¢	ê¸°ë³¸ì ìœ¼ë¡œ 90ë¶„ ë™ì•ˆ ìºì‹œëœ í† í°ì„ ë°˜í™˜í•˜ì§€ë§Œ, forceRenew í”Œë˜ê·¸ê°€ trueë¡œ ì„¤ì •ë˜ë©´ ê°•ì œë¡œ ìƒˆë¡œìš´ í† í°ì„ ë°œê¸‰ë°›ìŠµë‹ˆë‹¤.
	3.	RestTemplateConfig:
	â€¢	RestTemplateì— ì¸í„°ì…‰í„°ë¥¼ ì¶”ê°€í•˜ì—¬ ëª¨ë“  ìš”ì²­ì´ ì´ ì¸í„°ì…‰í„°ë¥¼ ê±°ì¹˜ë„ë¡ ì„¤ì •í•©ë‹ˆë‹¤.

ì „ì²´ íë¦„:

	1.	ì •ìƒì ì¸ ìš”ì²­: ì—‘ì„¸ìŠ¤ í† í°ì´ ìœ íš¨í•œ ë™ì•ˆì—ëŠ” ìºì‹±ëœ í† í°ì„ ì‚¬ìš©í•˜ì—¬ ìš”ì²­ì„ ë³´ëƒ…ë‹ˆë‹¤.
	2.	401 ì˜¤ë¥˜ ë°œìƒ ì‹œ: ì—‘ì„¸ìŠ¤ í† í°ì´ ë§Œë£Œë˜ì—ˆê±°ë‚˜ ìœ íš¨í•˜ì§€ ì•Šì€ ê²½ìš°, 401 ìƒíƒœ ì½”ë“œë¥¼ ê°ì§€í•˜ì—¬ ìƒˆë¡œìš´ í† í°ì„ ë°œê¸‰ë°›ê³ , ë™ì¼í•œ ìš”ì²­ì„ ë‹¤ì‹œ ì‹œë„í•©ë‹ˆë‹¤.
	3.	ê°•ì œ í† í° ê°±ì‹ : CachedTokenServiceëŠ” ê¸°ë³¸ì ìœ¼ë¡œ ìºì‹œëœ í† í°ì„ ë°˜í™˜í•˜ì§€ë§Œ, 401 ì˜¤ë¥˜ê°€ ë°œìƒí•˜ë©´ ê°•ì œë¡œ í† í°ì„ ê°±ì‹ í•©ë‹ˆë‹¤.

ì´ë ‡ê²Œ êµ¬í˜„í•˜ë©´ í•œ ì‹œê°„ ë°˜ ë™ì•ˆ ìœ íš¨í•œ í† í°ì„ ì‚¬ìš©í•˜ë©°, í† í°ì´ ë§Œë£Œë˜ê±°ë‚˜ 401 ì˜¤ë¥˜ê°€ ë°œìƒí•  ë•Œë§ˆë‹¤ ìƒˆë¡œìš´ í† í°ì„ ë°›ì•„ ë‹¤ì‹œ ìš”ì²­ì„ ì‹œë„í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.