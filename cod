🚀 Access Token 만료와 쿠키, 401 에러의 관계

📚 1. Access Token 만료와 쿠키의 역할
	•	Access Token 만료 시간은 JWT의 exp(Expiration) 클레임과 쿠키의 maxAge에 의해 정의됩니다.
	•	쿠키 만료와 Access Token 만료는 별개이지만 상호작용합니다.

✅ 2. 흐름 설명

📍 1. Access Token과 쿠키 만료 시간 설정
	•	Access Token의 만료 시간(exp)은 JWT 내부에 설정됩니다.
	•	쿠키(HttpOnly)에도 maxAge 또는 Expires 속성으로 만료 시간이 설정됩니다.

예시:

ResponseCookie accessTokenCookie = ResponseCookie.from("access_token", accessToken)
        .httpOnly(true)
        .secure(true)
        .path("/")
        .maxAge((expiration.getTime() - System.currentTimeMillis()) / 1000) // JWT 만료 시간과 동일
        .sameSite("Strict")
        .build();

📍 2. 클라이언트 요청 흐름
	1.	사용자는 Access Token을 HttpOnly 쿠키에 저장합니다.
	2.	HTTP 요청 시 브라우저는 쿠키에 포함된 Access Token을 서버로 전송합니다.
	3.	서버는 JwtAuthenticationFilter에서 Access Token을 검증합니다.

✅ 3. Access Token 검증 과정

📍 JwtAuthenticationFilter.java

@Override
protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)
        throws ServletException, IOException {

    String accessToken = extractTokenFromCookie(request);

    if (accessToken != null) {
        try {
            if (!tokenValidator.validateToken(accessToken)) {
                throw new RuntimeException("Token expired");
            }

            String username = tokenValidator.getUsernameFromToken(accessToken);
            UsernamePasswordAuthenticationToken authentication =
                new UsernamePasswordAuthenticationToken(username, null, tokenValidator.getAuthorities(accessToken));

            SecurityContextHolder.getContext().setAuthentication(authentication);
        } catch (Exception e) {
            // ✅ 만료된 경우 401 반환
            response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
            response.getWriter().write("{\"error\":\"TOKEN_EXPIRED\"}");
            return;
        }
    } else {
        // ✅ 쿠키에 Access Token이 없는 경우
        response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
        response.getWriter().write("{\"error\":\"TOKEN_MISSING\"}");
        return;
    }

    filterChain.doFilter(request, response);
}

private String extractTokenFromCookie(HttpServletRequest request) {
    if (request.getCookies() != null) {
        for (Cookie cookie : request.getCookies()) {
            if ("access_token".equals(cookie.getName())) {
                return cookie.getValue();
            }
        }
    }
    return null;
}

✅ 4. 시나리오별 동작 방식

상황	Access Token 상태	쿠키 상태	결과
1. 유효한 토큰	만료되지 않음	쿠키 존재	✅ 정상 처리
2. 만료된 토큰	만료됨	쿠키 존재	❌ 401 Unauthorized 반환
3. 쿠키 만료	-	쿠키 없음	❌ 401 Unauthorized 반환 (TOKEN_MISSING)
4. 토큰 변조	유효하지 않음	쿠키 존재	❌ 401 Unauthorized 반환

🔑 설명
	1.	만료된 토큰
	•	토큰은 쿠키에 남아있지만 exp가 지나면 validateToken에서 만료로 판단하고 401 에러를 반환합니다.
	2.	쿠키가 만료됨
	•	브라우저가 만료된 쿠키를 자동으로 삭제합니다.
	•	서버에 Access Token이 전송되지 않아서 extractTokenFromCookie가 null을 반환합니다.
	•	서버는 401 Unauthorized 오류를 반환합니다.

✅ 5. 쿠키와 Access Token 시간 일치

📍 Access Token과 쿠키 만료 시간 동기화
	•	**Access Token 만료 시간(exp)**과 **쿠키 만료 시간(maxAge)**을 일치시켜야 합니다.
	•	설정 예시:

Date expiration = tokenValidator.getExpirationDateFromToken(accessToken);

ResponseCookie accessTokenCookie = ResponseCookie.from("access_token", accessToken)
        .httpOnly(true)
        .secure(true)
        .path("/")
        .maxAge((expiration.getTime() - System.currentTimeMillis()) / 1000)
        .sameSite("Strict")
        .build();

🔑 설명
	•	maxAge는 JWT의 만료 시간과 일치해야 합니다.
	•	일치하지 않으면 JWT는 유효하지만 쿠키가 삭제되어 요청할 수 없는 문제가 발생할 수 있습니다.

✅ 6. 프론트엔드 처리 (React)

📍 Axios Interceptor로 401 에러 처리

import axios from 'axios';

axios.defaults.withCredentials = true;

// Axios Interceptor
axios.interceptors.response.use(
    response => response,
    error => {
        if (error.response && error.response.status === 401) {
            if (error.response.data.error === "TOKEN_MISSING") {
                console.warn('Token missing, redirecting to login...');
            } else if (error.response.data.error === "TOKEN_EXPIRED") {
                console.warn('Token expired, redirecting to re-authenticate...');
            }
            window.location.href = '/oauth/authorize';
        }
        return Promise.reject(error);
    }
);

✅ 7. 최종 흐름
	1.	Access Token 유효:
	•	요청 처리 정상 작동.
	2.	Access Token 만료 (exp 지남):
	•	401 Unauthorized와 TOKEN_EXPIRED 응답.
	•	React가 /oauth/authorize로 리다이렉션.
	3.	쿠키 만료:
	•	Access Token이 서버로 전달되지 않음.
	•	401 Unauthorized와 TOKEN_MISSING 응답.
	•	React가 /oauth/authorize로 리다이렉션.
	4.	다시 Access Code를 요청:
	•	사용자는 /oauth/authorize에서 Access Code를 받아 Access Token을 재발급.

✅ 8. 최종 정리
	•	Access Token 만료는 JWT의 exp 클레임으로 확인합니다.
	•	브라우저 쿠키 만료는 maxAge나 Expires 속성으로 확인합니다.
	•	Access Token 만료: 401 Unauthorized와 TOKEN_EXPIRED 반환.
	•	쿠키 만료: 401 Unauthorized와 TOKEN_MISSING 반환.
	•	프론트엔드에서 401 응답을 감지해 /oauth/authorize로 리디렉션.

이제 Access Token과 쿠키 만료를 안전하게 다루고 재인증을 유도할 수 있습니다! 🚀🔐✨





🚀 Access Token 만료와 쿠키, 401 에러의 관계

📚 1. Access Token 만료와 쿠키의 역할
	•	Access Token 만료 시간은 JWT의 exp(Expiration) 클레임과 쿠키의 maxAge에 의해 정의됩니다.
	•	쿠키 만료와 Access Token 만료는 별개이지만 상호작용합니다.

✅ 2. 흐름 설명

📍 1. Access Token과 쿠키 만료 시간 설정
	•	Access Token의 만료 시간(exp)은 JWT 내부에 설정됩니다.
	•	쿠키(HttpOnly)에도 maxAge 또는 Expires 속성으로 만료 시간이 설정됩니다.

예시:

ResponseCookie accessTokenCookie = ResponseCookie.from("access_token", accessToken)
        .httpOnly(true)
        .secure(true)
        .path("/")
        .maxAge((expiration.getTime() - System.currentTimeMillis()) / 1000) // JWT 만료 시간과 동일
        .sameSite("Strict")
        .build();

📍 2. 클라이언트 요청 흐름
	1.	사용자는 Access Token을 HttpOnly 쿠키에 저장합니다.
	2.	HTTP 요청 시 브라우저는 쿠키에 포함된 Access Token을 서버로 전송합니다.
	3.	서버는 JwtAuthenticationFilter에서 Access Token을 검증합니다.

✅ 3. Access Token 검증 과정

📍 JwtAuthenticationFilter.java

@Override
protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)
        throws ServletException, IOException {

    String accessToken = extractTokenFromCookie(request);

    if (accessToken != null) {
        try {
            if (!tokenValidator.validateToken(accessToken)) {
                throw new RuntimeException("Token expired");
            }

            String username = tokenValidator.getUsernameFromToken(accessToken);
            UsernamePasswordAuthenticationToken authentication =
                new UsernamePasswordAuthenticationToken(username, null, tokenValidator.getAuthorities(accessToken));

            SecurityContextHolder.getContext().setAuthentication(authentication);
        } catch (Exception e) {
            // ✅ 만료된 경우 401 반환
            response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
            response.getWriter().write("{\"error\":\"TOKEN_EXPIRED\"}");
            return;
        }
    } else {
        // ✅ 쿠키에 Access Token이 없는 경우
        response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
        response.getWriter().write("{\"error\":\"TOKEN_MISSING\"}");
        return;
    }

    filterChain.doFilter(request, response);
}

private String extractTokenFromCookie(HttpServletRequest request) {
    if (request.getCookies() != null) {
        for (Cookie cookie : request.getCookies()) {
            if ("access_token".equals(cookie.getName())) {
                return cookie.getValue();
            }
        }
    }
    return null;
}

✅ 4. 시나리오별 동작 방식

상황	Access Token 상태	쿠키 상태	결과
1. 유효한 토큰	만료되지 않음	쿠키 존재	✅ 정상 처리
2. 만료된 토큰	만료됨	쿠키 존재	❌ 401 Unauthorized 반환
3. 쿠키 만료	-	쿠키 없음	❌ 401 Unauthorized 반환 (TOKEN_MISSING)
4. 토큰 변조	유효하지 않음	쿠키 존재	❌ 401 Unauthorized 반환

🔑 설명
	1.	만료된 토큰
	•	토큰은 쿠키에 남아있지만 exp가 지나면 validateToken에서 만료로 판단하고 401 에러를 반환합니다.
	2.	쿠키가 만료됨
	•	브라우저가 만료된 쿠키를 자동으로 삭제합니다.
	•	서버에 Access Token이 전송되지 않아서 extractTokenFromCookie가 null을 반환합니다.
	•	서버는 401 Unauthorized 오류를 반환합니다.

✅ 5. 쿠키와 Access Token 시간 일치

📍 Access Token과 쿠키 만료 시간 동기화
	•	**Access Token 만료 시간(exp)**과 **쿠키 만료 시간(maxAge)**을 일치시켜야 합니다.
	•	설정 예시:

Date expiration = tokenValidator.getExpirationDateFromToken(accessToken);

ResponseCookie accessTokenCookie = ResponseCookie.from("access_token", accessToken)
        .httpOnly(true)
        .secure(true)
        .path("/")
        .maxAge((expiration.getTime() - System.currentTimeMillis()) / 1000)
        .sameSite("Strict")
        .build();

🔑 설명
	•	maxAge는 JWT의 만료 시간과 일치해야 합니다.
	•	일치하지 않으면 JWT는 유효하지만 쿠키가 삭제되어 요청할 수 없는 문제가 발생할 수 있습니다.

✅ 6. 프론트엔드 처리 (React)

📍 Axios Interceptor로 401 에러 처리

import axios from 'axios';

axios.defaults.withCredentials = true;

// Axios Interceptor
axios.interceptors.response.use(
    response => response,
    error => {
        if (error.response && error.response.status === 401) {
            if (error.response.data.error === "TOKEN_MISSING") {
                console.warn('Token missing, redirecting to login...');
            } else if (error.response.data.error === "TOKEN_EXPIRED") {
                console.warn('Token expired, redirecting to re-authenticate...');
            }
            window.location.href = '/oauth/authorize';
        }
        return Promise.reject(error);
    }
);

✅ 7. 최종 흐름
	1.	Access Token 유효:
	•	요청 처리 정상 작동.
	2.	Access Token 만료 (exp 지남):
	•	401 Unauthorized와 TOKEN_EXPIRED 응답.
	•	React가 /oauth/authorize로 리다이렉션.
	3.	쿠키 만료:
	•	Access Token이 서버로 전달되지 않음.
	•	401 Unauthorized와 TOKEN_MISSING 응답.
	•	React가 /oauth/authorize로 리다이렉션.
	4.	다시 Access Code를 요청:
	•	사용자는 /oauth/authorize에서 Access Code를 받아 Access Token을 재발급.

✅ 8. 최종 정리
	•	Access Token 만료는 JWT의 exp 클레임으로 확인합니다.
	•	브라우저 쿠키 만료는 maxAge나 Expires 속성으로 확인합니다.
	•	Access Token 만료: 401 Unauthorized와 TOKEN_EXPIRED 반환.
	•	쿠키 만료: 401 Unauthorized와 TOKEN_MISSING 반환.
	•	프론트엔드에서 401 응답을 감지해 /oauth/authorize로 리디렉션.

이제 Access Token과 쿠키 만료를 안전하게 다루고 재인증을 유도할 수 있습니다! 🚀🔐✨










🚀 Access Code 기반 OAuth 2.0 Flow에서 Access Token 만료 처리 (Refresh Token 없이)

📚 1. 목표
	1.	Refresh Token 없이 Access Token이 만료된 경우, 사용자는 Access Code Flow를 통해 새 Access Token을 받아야 합니다.
	2.	Access Token 만료 시 클라이언트가 Access Code를 다시 요청하도록 유도합니다.
	3.	백엔드와 프론트엔드가 올바르게 Access Token 만료를 감지하고 처리합니다.

⚙️ 2. Access Code Flow 요약
	1.	사용자는 Authorization Server로 리디렉션됩니다.
	2.	사용자 인증 후 Access Code가 발급됩니다.
	3.	클라이언트는 Access Code를 백엔드로 전달합니다.
	4.	백엔드는 Access Code를 사용해 Access Token을 발급받습니다.
	5.	Access Token이 만료되면 사용자는 다시 Access Code를 요청해야 합니다.

🛠️ 3. 백엔드 처리

✅ 3.1 JwtAuthenticationFilter 수정

📍 JwtAuthenticationFilter.java

import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.web.filter.OncePerRequestFilter;

import javax.servlet.FilterChain;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

public class JwtAuthenticationFilter extends OncePerRequestFilter {

    private final TokenValidator tokenValidator;

    public JwtAuthenticationFilter(TokenValidator tokenValidator) {
        this.tokenValidator = tokenValidator;
    }

    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)
            throws ServletException, IOException {

        String accessToken = extractTokenFromRequest(request);

        if (accessToken != null) {
            try {
                if (!tokenValidator.validateToken(accessToken)) {
                    throw new RuntimeException("Token expired");
                }

                String username = tokenValidator.getUsernameFromToken(accessToken);
                UsernamePasswordAuthenticationToken authentication = 
                    new UsernamePasswordAuthenticationToken(username, null, tokenValidator.getAuthorities(accessToken));

                SecurityContextHolder.getContext().setAuthentication(authentication);
            } catch (Exception e) {
                // ✅ 토큰 만료 시 401 반환 및 리디렉션 유도
                response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
                response.getWriter().write("{\"error\":\"TOKEN_EXPIRED\", \"redirect_uri\":\"/oauth/authorize\"}");
                return;
            }
        }

        filterChain.doFilter(request, response);
    }

    private String extractTokenFromRequest(HttpServletRequest request) {
        String bearerToken = request.getHeader("Authorization");
        if (bearerToken != null && bearerToken.startsWith("Bearer ")) {
            return bearerToken.substring(7);
        }
        return null;
    }
}

🔑 설명
	1.	Access Token 검증
	•	validateToken 메서드를 통해 토큰 유효성 확인.
	2.	토큰 만료 감지
	•	토큰이 만료되면 401 Unauthorized 상태 코드 반환.
	•	JSON 응답으로 redirect_uri를 전달해 프론트엔드가 Access Code 요청을 유도할 수 있게 함.

✅ 3.2 AuthController

📍 AuthController.java

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseCookie;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestParam;

import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.util.*;
import java.util.stream.Collectors;

@Controller
public class AuthController {

    @Autowired
    private OAuth2TokenService oAuth2TokenService;

    @Autowired
    private TokenValidator tokenValidator;

    @GetMapping("/handle_redirect")
    public void handleOAuthCallback(
            @RequestParam String code,
            @RequestParam(required = false) String state,
            HttpServletResponse response
    ) throws IOException {
        try {
            if (state == null || !isValidState(state)) {
                response.sendRedirect("/error?message=Invalid state parameter");
                return;
            }

            // Access Code → Access Token 교환
            Map<String, String> tokens = oAuth2TokenService.exchangeAuthorizationCode(code);
            String accessToken = tokens.get("access_token");
            String username = tokenValidator.getUsernameFromToken(accessToken);
            Date expiration = tokenValidator.getExpirationDateFromToken(accessToken);

            // SecurityContext 저장
            List<String> roles = tokenValidator.getRolesFromToken(accessToken);
            List<GrantedAuthority> authorities = roles.stream()
                    .map(role -> new SimpleGrantedAuthority("ROLE_" + role))
                    .collect(Collectors.toList());

            UsernamePasswordAuthenticationToken authentication =
                    new UsernamePasswordAuthenticationToken(username, null, authorities);
            SecurityContextHolder.getContext().setAuthentication(authentication);

            // HttpOnly 쿠키에 저장
            ResponseCookie accessTokenCookie = ResponseCookie.from("access_token", accessToken)
                    .httpOnly(true)
                    .secure(true)
                    .path("/")
                    .maxAge((expiration.getTime() - System.currentTimeMillis()) / 1000)
                    .sameSite("Strict")
                    .build();

            response.addHeader("Set-Cookie", accessTokenCookie.toString());
            response.sendRedirect("/ui");
        } catch (Exception e) {
            response.sendRedirect("/error?message=Failed to handle OAuth2 callback");
        }
    }

    private boolean isValidState(String state) {
        return "expected_state_value".equals(state);
    }
}

⚛️ 4. 프론트엔드 처리 (React)

✅ 4.1 Axios Interceptor

📍 AuthService.js

import axios from 'axios';

axios.defaults.withCredentials = true;

// Axios 인터셉터
axios.interceptors.response.use(
    response => response,
    error => {
        if (error.response && error.response.status === 401) {
            const redirectUri = error.response.data?.redirect_uri || '/login';
            console.warn('Token expired, redirecting to re-authenticate...');
            window.location.href = redirectUri;
        }
        return Promise.reject(error);
    }
);

/**
 * API 호출 예시
 */
export const fetchProtectedData = async () => {
    try {
        const response = await axios.get('/api/protected');
        return response.data;
    } catch (error) {
        console.error('Failed to fetch protected data:', error);
        throw error;
    }
};

🔑 설명
	1.	401 Unauthorized 감지
	•	만료된 Access Token이 감지되면 redirect_uri로 이동.
	2.	Access Code Flow 재시작
	•	사용자는 /oauth/authorize로 리디렉션되어 Access Code를 다시 받습니다.

✅ 4.2 OAuthCallback.js

📍 OAuthCallback.js

import React, { useEffect } from 'react';
import { useSearchParams, useNavigate } from 'react-router-dom';

function OAuthCallback() {
    const [searchParams] = useSearchParams();
    const navigate = useNavigate();

    useEffect(() => {
        const code = searchParams.get('code');
        if (code) {
            axios.get(`/handle_redirect?code=${code}`)
                .then(() => {
                    navigate('/ui');
                })
                .catch(() => {
                    navigate('/error');
                });
        } else {
            navigate('/error');
        }
    }, [navigate, searchParams]);

    return <div>Authenticating...</div>;
}

✅ 5. 흐름 요약
	1.	Access Token 만료 → 401 Unauthorized
	2.	프론트엔드 Interceptor가 리다이렉션 유도
	3.	사용자 /oauth/authorize로 이동 → Access Code 발급
	4.	Access Code → Access Token 교환
	5.	새 Access Token으로 보호된 리소스 접근

🎯 6. 최종 정리

✅ Access Token 만료 감지 및 리디렉션
✅ Access Code Flow 재시작
✅ 보안 및 사용자 경험 개선

이제 Refresh Token 없이 Access Token 만료를 안전하고 효율적으로 처리할 수 있습니다! 🚀🔑✨






🚀 React + Spring Boot OAuth2 + Test Account 통합 예제

📚 1. 프로젝트 구조

✅ Backend (Spring Boot)

/src/main/java/com/example/security
├── config/
│   ├── SecurityConfig.java      // Spring Security 설정
│   ├── CorsConfig.java          // CORS 설정
│   ├── JwtTokenUtil.java        // JWT 토큰 유틸리티
│   ├── TokenValidator.java      // JWT 토큰 검증
├── controller/
│   ├── AuthController.java      // OAuth2 & Test Account 컨트롤러
├── oauth2/
│   ├── OAuth2TokenService.java  // Authorization Code → Access Token
├── service/
│   ├── TestAccountService.java  // Test Account 인증 서비스
├── filter/
│   ├── JwtAuthenticationFilter.java  // JWT 필터
└── application.yml              // 환경설정

✅ Frontend (React)

/src
├── index.js
├── App.js
├── routes.js        // 라우터 설정
├── services/
│   ├── AuthService.js // 인증 서비스
├── pages/
│   ├── Login.js       // 로그인 페이지
│   ├── OAuthCallback.js // OAuth 리다이렉트 처리
│   ├── ProtectedResource.js // 보호된 페이지

🔑 2. Backend (Spring Boot)

✅ 2.1 SecurityConfig.java

package com.example.security.config;

import com.example.security.filter.JwtAuthenticationFilter;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;

@Configuration
public class SecurityConfig {

    private final JwtAuthenticationFilter jwtAuthenticationFilter;

    public SecurityConfig(JwtAuthenticationFilter jwtAuthenticationFilter) {
        this.jwtAuthenticationFilter = jwtAuthenticationFilter;
    }

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
            .cors().and()
            .csrf().disable()
            .authorizeHttpRequests(auth -> auth
                .requestMatchers("/api/oauth/**").permitAll()
                .requestMatchers("/handle_redirect").permitAll()
                .requestMatchers("/api/auth/test-login").permitAll()
                .anyRequest().authenticated()
            )
            .sessionManagement(session -> session
                .sessionCreationPolicy(SessionCreationPolicy.STATELESS)
            )
            .addFilterBefore(jwtAuthenticationFilter, UsernamePasswordAuthenticationFilter.class);

        return http.build();
    }
}

✅ 2.2 AuthController.java

package com.example.security.controller;

import com.example.security.oauth2.OAuth2TokenService;
import com.example.security.jwt.TokenValidator;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.web.bind.annotation.*;

import javax.servlet.http.HttpServletRequest;
import java.util.Collections;
import java.util.Map;

@RestController
@RequestMapping("/api/auth")
public class AuthController {

    @Autowired
    private OAuth2TokenService oAuth2TokenService;

    @Autowired
    private TokenValidator tokenValidator;

    @PostMapping("/handle_redirect")
    public ResponseEntity<Map<String, String>> handleOAuthCallback(@RequestParam String code, HttpServletRequest request) {
        Map<String, String> tokens = oAuth2TokenService.exchangeAuthorizationCode(code);
        String accessToken = tokens.get("access_token");
        String username = tokenValidator.getUsernameFromToken(accessToken);
        String role = tokenValidator.getRoleFromToken(accessToken);

        UsernamePasswordAuthenticationToken authentication = new UsernamePasswordAuthenticationToken(
                username, null, Collections.singleton(() -> "ROLE_" + role)
        );
        SecurityContextHolder.getContext().setAuthentication(authentication);

        return ResponseEntity.ok(Map.of(
                "accessToken", accessToken,
                "username", username,
                "role", role
        ));
    }

    @PostMapping("/test-login")
    public ResponseEntity<Map<String, String>> testLogin(@RequestParam String username, @RequestParam String password) {
        if ("testUser".equals(username) && "password123".equals(password)) {
            String accessToken = "testAccessToken";
            return ResponseEntity.ok(Map.of(
                    "accessToken", accessToken,
                    "username", username,
                    "role", "USER"
            ));
        }
        return ResponseEntity.badRequest().body(Map.of("error", "Invalid credentials"));
    }
}

✅ 2.3 OAuth2TokenService.java

package com.example.security.oauth2;

import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;

import java.util.Map;

@Service
public class OAuth2TokenService {

    public Map<String, String> exchangeAuthorizationCode(String code) {
        RestTemplate restTemplate = new RestTemplate();

        Map<String, String> request = Map.of(
                "grant_type", "authorization_code",
                "code", code,
                "redirect_uri", "https://localhost:8080/handle_redirect",
                "client_id", "your-client-id",
                "client_secret", "your-client-secret"
        );

        Map response = restTemplate.postForObject("https://idanywhere.com/oauth/token", request, Map.class);
        return Map.of(
                "access_token", response.get("access_token").toString()
        );
    }
}

⚛️ 3. Frontend (React)

✅ 3.1 routes.js

import { createBrowserRouter, RouterProvider } from 'react-router-dom';
import Login from './pages/Login';
import OAuthCallback from './pages/OAuthCallback';
import ProtectedResource from './pages/ProtectedResource';

const router = createBrowserRouter([
    { path: '/', element: <Login /> },
    { path: '/handle_redirect', element: <OAuthCallback /> },
    { path: '/protected', element: <ProtectedResource /> },
]);

export default router;

✅ 3.2 Login.js

import React, { useState } from 'react';
import { testLogin } from '../services/AuthService';

function Login() {
    const [username, setUsername] = useState('');
    const [password, setPassword] = useState('');

    const handleOAuthLogin = () => {
        window.location.href = 'https://idanywhere.com/oauth/authorize?' +
            'client_id=your-client-id&response_type=code&' +
            'redirect_uri=https://localhost:8080/handle_redirect';
    };

    const handleTestLogin = async () => {
        await testLogin(username, password);
        window.location.href = '/protected';
    };

    return (
        <div>
            <button onClick={handleOAuthLogin}>OAuth Login</button>
            <input value={username} onChange={(e) => setUsername(e.target.value)} />
            <input value={password} onChange={(e) => setPassword(e.target.value)} />
            <button onClick={handleTestLogin}>Test Login</button>
        </div>
    );
}

✅ 3.3 AuthService.js

import axios from 'axios';

export const fetchAccessToken = async (code) => {
    const response = await axios.post(`/api/auth/handle_redirect?code=${code}`);
    localStorage.setItem('accessToken', response.data.accessToken);
};

export const testLogin = async (username, password) => {
    const response = await axios.post('/api/auth/test-login', { username, password });
    localStorage.setItem('accessToken', response.data.accessToken);
};

✅ 3.4 ProtectedResource.js

import React, { useEffect } from 'react';

function ProtectedResource() {
    useEffect(() => {
        console.log('Access Protected Resource');
    }, []);

    return <div>Protected Resource</div>;
}

🎯 4. 요약
	1.	✅ OAuth2 로그인 (/handle_redirect)
	2.	✅ Test Account 로그인 (/test-login)
	3.	✅ JWT 토큰 인증
	4.	✅ React Router로 페이지 관리

이제 완전한 OAuth2 + Test Account + React + Spring Boot 통합 프로젝트가 완성되었습니다! 🚀🔐







🔄 React에서 createBrowserRouter를 사용하여 OAuth2 Redirect 처리하기

📚 1. createBrowserRouter란?
	•	createBrowserRouter는 React Router v6.4 이상에서 사용되는 API입니다.
	•	BrowserRouter보다 더 명확하게 라우터를 정의할 수 있습니다.
	•	OAuth2 Redirect 처리를 포함한 복잡한 라우팅 설정에 적합합니다.

⚛️ 2. 프로젝트 구조

/src
├── index.js
├── App.js
├── routes.js   // 라우팅 정의
├── pages/
│   ├── Login.js
│   ├── OAuthCallback.js
│   ├── ProtectedResource.js
└── services/
    ├── AuthService.js

✅ 3. 라우터 설정

📌 3.1 routes.js

import { createBrowserRouter, RouterProvider } from 'react-router-dom';
import Login from './pages/Login';
import OAuthCallback from './pages/OAuthCallback';
import ProtectedResource from './pages/ProtectedResource';

const router = createBrowserRouter([
    {
        path: '/',
        element: <Login />,
    },
    {
        path: '/handle_redirect',
        element: <OAuthCallback />,
    },
    {
        path: '/protected',
        element: <ProtectedResource />,
    },
    {
        path: '*',
        element: <div>404 - Page Not Found</div>,
    },
]);

export default router;

📌 3.2 index.js

import React from 'react';
import ReactDOM from 'react-dom/client';
import { RouterProvider } from 'react-router-dom';
import router from './routes';

ReactDOM.createRoot(document.getElementById('root')).render(
    <React.StrictMode>
        <RouterProvider router={router} />
    </React.StrictMode>
);

✅ 4. OAuthCallback.js

OAuth2 Redirect 처리 컴포넌트

import React, { useEffect } from 'react';
import { fetchAccessToken } from '../services/AuthService';
import { useNavigate, useSearchParams } from 'react-router-dom';

function OAuthCallback() {
    const [searchParams] = useSearchParams();
    const navigate = useNavigate();

    useEffect(() => {
        const code = searchParams.get('code');
        if (code) {
            fetchAccessToken(code)
                .then(() => {
                    console.log('Access Token successfully fetched');
                    navigate('/protected'); // 성공 시 Protected 페이지로 이동
                })
                .catch((error) => {
                    console.error('Failed to fetch access token:', error);
                    navigate('/login'); // 실패 시 로그인 페이지로 이동
                });
        } else {
            console.error('Authorization code is missing');
            navigate('/login');
        }
    }, [navigate, searchParams]);

    return (
        <div>
            <h2>Authenticating...</h2>
            <p>Please wait while we process your authentication.</p>
        </div>
    );
}

export default OAuthCallback;

✅ 설명:
	1.	useSearchParams:
	•	URL에서 code 파라미터를 추출합니다.
	2.	fetchAccessToken:
	•	code를 사용하여 Access Token을 요청합니다.
	3.	useNavigate:
	•	요청 성공 시 /protected로 이동합니다.
	•	실패 시 /login으로 이동합니다.

✅ 5. Login.js

OAuth2 및 Test Account 로그인

import React, { useState } from 'react';
import { testLogin } from '../services/AuthService';

function Login() {
    const [username, setUsername] = useState('');
    const [password, setPassword] = useState('');

    const handleOAuthLogin = () => {
        window.location.href = 'https://idanywhere.com/oauth/authorize?' +
            'client_id=your-client-id&' +
            'response_type=code&' +
            'redirect_uri=https://localhost:8080/handle_redirect';
    };

    const handleTestLogin = async () => {
        if (!username || !password) {
            alert('Please enter username and password');
            return;
        }
        await testLogin(username, password);
        window.location.href = '/protected';
    };

    return (
        <div style={{ padding: '20px' }}>
            <h2>🔐 Login</h2>

            {/* ✅ OAuth2 로그인 버튼 */}
            <button onClick={handleOAuthLogin} style={{ marginBottom: '10px' }}>
                Login with OAuth2
            </button>

            <hr />

            {/* ✅ Test Account 로그인 */}
            <h3>Test Account Login</h3>
            <input
                type="text"
                placeholder="Username"
                value={username}
                onChange={(e) => setUsername(e.target.value)}
            />
            <br />
            <input
                type="password"
                placeholder="Password"
                value={password}
                onChange={(e) => setPassword(e.target.value)}
            />
            <br />
            <button onClick={handleTestLogin}>Login with Test Account</button>
        </div>
    );
}

export default Login;

✅ 6. AuthService.js

API 호출 및 토큰 관리

import axios from 'axios';

export const testLogin = async (username, password) => {
    try {
        const response = await axios.post('/api/auth/test-login', null, {
            params: { username, password },
        });
        const { accessToken, username: user, role } = response.data;
        localStorage.setItem('accessToken', accessToken);
        localStorage.setItem('username', user);
        localStorage.setItem('role', role);
        console.log('Test Account Login Successful');
    } catch (error) {
        console.error('Test Account Login Failed:', error.response?.data || error.message);
    }
};

export const fetchAccessToken = async (code) => {
    try {
        const response = await axios.get(`/api/auth/handle_redirect?code=${code}`);
        const { accessToken, username: user, role } = response.data;
        localStorage.setItem('accessToken', accessToken);
        localStorage.setItem('username', user);
        localStorage.setItem('role', role);
        console.log('OAuth2 Login Successful');
    } catch (error) {
        console.error('OAuth2 Login Failed:', error.response?.data || error.message);
    }
};

export const logout = () => {
    localStorage.removeItem('accessToken');
    localStorage.removeItem('username');
    localStorage.removeItem('role');
    console.log('Logged out successfully');
};

✅ 7. ProtectedResource.js

import React, { useEffect, useState } from 'react';
import axios from 'axios';

function ProtectedResource() {
    const [data, setData] = useState('');

    useEffect(() => {
        const fetchData = async () => {
            try {
                const accessToken = localStorage.getItem('accessToken');
                const response = await axios.get('/api/user/me', {
                    headers: {
                        Authorization: `Bearer ${accessToken}`,
                    },
                });
                setData(response.data);
            } catch (error) {
                console.error('Failed to fetch resource:', error.response?.data || error.message);
            }
        };

        fetchData();
    }, []);

    return (
        <div>
            <h2>Protected Resource</h2>
            <p>{data}</p>
        </div>
    );
}

export default ProtectedResource;

🎯 8. 최종 요약
	1.	✅ OAuth2 + Test Account 통합 로그인 지원
	2.	✅ createBrowserRouter로 명확한 라우팅
	3.	✅ useEffect로 Redirect 처리
	4.	✅ Access Token 관리 및 API 요청 지원

이제 createBrowserRouter와 함께 OAuth2 + Test Account 통합 인증이 완벽하게 설정되었습니다! 🚀🔑






🔑 React: OAuth2 + Test Account 통합 로그인 예제

📚 1. 목표
	1.	OAuth2 로그인
	•	Authorization Code → Access Token
	2.	Test Account 로그인
	•	Username + Password → Access Token
	3.	Access Token 저장 및 API 요청 시 사용
	4.	Role 기반 접근 제어

⚛️ 2. AuthService.js

API 호출 및 Token 관리

import axios from 'axios';

// ✅ Test Account 로그인
export const testLogin = async (username, password) => {
    try {
        const response = await axios.post('/api/auth/test-login', null, {
            params: { username, password },
        });
        const { accessToken, username: user, role } = response.data;
        localStorage.setItem('accessToken', accessToken);
        localStorage.setItem('username', user);
        localStorage.setItem('role', role);
        console.log('Test Account Login Successful');
    } catch (error) {
        console.error('Test Account Login Failed:', error.response?.data || error.message);
    }
};

// ✅ OAuth2 Access Token 요청
export const fetchAccessToken = async (code) => {
    try {
        const response = await axios.get(`/api/auth/handle_redirect?code=${code}`);
        const { accessToken, username: user, role } = response.data;
        localStorage.setItem('accessToken', accessToken);
        localStorage.setItem('username', user);
        localStorage.setItem('role', role);
        console.log('OAuth2 Login Successful');
    } catch (error) {
        console.error('OAuth2 Login Failed:', error.response?.data || error.message);
    }
};

// ✅ API 요청 (Access Token 포함)
export const fetchProtectedResource = async () => {
    try {
        const accessToken = localStorage.getItem('accessToken');
        const response = await axios.get('/api/user/me', {
            headers: {
                Authorization: `Bearer ${accessToken}`,
            },
        });
        console.log('Protected Resource:', response.data);
    } catch (error) {
        console.error('Failed to fetch protected resource:', error.response?.data || error.message);
    }
};

// ✅ 로그아웃
export const logout = () => {
    localStorage.removeItem('accessToken');
    localStorage.removeItem('username');
    localStorage.removeItem('role');
    console.log('Logged out successfully');
};

⚛️ 3. Login.js

OAuth2 및 Test Account 로그인 UI

import React, { useEffect, useState } from 'react';
import { testLogin, fetchAccessToken, fetchProtectedResource, logout } from './AuthService';

function Login() {
    const [username, setUsername] = useState('');
    const [password, setPassword] = useState('');
    const [isAuthenticated, setIsAuthenticated] = useState(false);

    // ✅ OAuth2 로그인 핸들러
    const handleOAuthLogin = () => {
        window.location.href = 'https://idanywhere.com/oauth/authorize?' +
            'client_id=your-client-id&' +
            'response_type=code&' +
            'redirect_uri=https://localhost:8080/handle_redirect';
    };

    // ✅ Test Account 로그인 핸들러
    const handleTestLogin = async () => {
        if (!username || !password) {
            alert('Please enter username and password');
            return;
        }
        await testLogin(username, password);
        setIsAuthenticated(true);
    };

    // ✅ OAuth2 Callback 처리
    useEffect(() => {
        const query = new URLSearchParams(window.location.search);
        const code = query.get('code');
        if (code) {
            fetchAccessToken(code).then(() => {
                setIsAuthenticated(true);
                window.history.replaceState({}, document.title, window.location.pathname);
            });
        }
    }, []);

    return (
        <div style={{ padding: '20px' }}>
            <h2>🔐 Login</h2>

            {/* ✅ OAuth2 로그인 버튼 */}
            <button onClick={handleOAuthLogin} style={{ marginBottom: '10px' }}>
                Login with OAuth2
            </button>

            <hr />

            {/* ✅ Test Account 로그인 */}
            <h3>Test Account Login</h3>
            <input
                type="text"
                placeholder="Username"
                value={username}
                onChange={(e) => setUsername(e.target.value)}
            />
            <br />
            <input
                type="password"
                placeholder="Password"
                value={password}
                onChange={(e) => setPassword(e.target.value)}
            />
            <br />
            <button onClick={handleTestLogin}>Login with Test Account</button>

            <hr />

            {/* ✅ 인증된 사용자 정보 확인 */}
            {isAuthenticated && (
                <div>
                    <h3>✅ Authenticated</h3>
                    <button onClick={fetchProtectedResource}>Fetch Protected Resource</button>
                    <br />
                    <button onClick={logout}>Logout</button>
                </div>
            )}
        </div>
    );
}

export default Login;

⚛️ 4. ProtectedResource.js

인증된 사용자 데이터 확인

import React, { useEffect, useState } from 'react';
import axios from 'axios';

function ProtectedResource() {
    const [data, setData] = useState('');

    useEffect(() => {
        const fetchData = async () => {
            try {
                const accessToken = localStorage.getItem('accessToken');
                const response = await axios.get('/api/user/me', {
                    headers: {
                        Authorization: `Bearer ${accessToken}`,
                    },
                });
                setData(response.data);
            } catch (error) {
                console.error('Failed to fetch resource:', error.response?.data || error.message);
            }
        };

        fetchData();
    }, []);

    return (
        <div>
            <h2>Protected Resource</h2>
            <p>{data}</p>
        </div>
    );
}

export default ProtectedResource;

🛡️ 5. API 요청 흐름
	1.	OAuth2 로그인:
	•	사용자는 OAuth2 Provider를 통해 Authorization Code를 얻습니다.
	•	백엔드가 Access Token을 가져오고, 사용자 정보를 반환합니다.
	2.	Test Account 로그인:
	•	사용자는 username과 password를 입력합니다.
	•	백엔드가 사용자를 검증하고 Access Token을 반환합니다.
	3.	Access Token 저장:
	•	Access Token은 localStorage에 저장됩니다.
	•	API 요청 시 Authorization: Bearer <Token> 헤더에 포함됩니다.
	4.	Protected API 요청:
	•	인증된 사용자는 API를 호출할 수 있습니다.

🎯 6. 최종 요약
	1.	OAuth2 로그인: Authorization Code → Access Token
	2.	Test Account 로그인: Username/Password → Access Token
	3.	React에서 Access Token 관리: localStorage 사용
	4.	Protected API 요청: Access Token 포함하여 요청
	5.	로그아웃 기능 지원: localStorage에서 Token 제거

🚀 7. 권장 사용
	1.	OAuth2: 실사용자 인증에 사용
	2.	Test Account: 개발 및 테스트 환경에서만 사용

이제 OAuth2 로그인과 Test Account 로그인이 통합된 React 앱이 완성되었습니다! 🎉🔐





public class LibraryWrapper {

    // 스레드별로 독립적인 상태를 유지하기 위해 ThreadLocal 사용
    private static final ThreadLocal<LibraryWrapper> threadLocalWrapper =
        ThreadLocal.withInitial(LibraryWrapper::new);

    // 라이브러리 싱글톤 인스턴스
    private final LibrarySingleton libraryInstance;

    // 각 스레드별 독립적인 상태
    private String customState;

    private LibraryWrapper() {
        this.libraryInstance = LibrarySingleton.getInstance(); // 싱글톤 인스턴스 참조
        this.customState = "default"; // 초기 상태 설정
    }

    public static LibraryWrapper getInstance() {
        return threadLocalWrapper.get();
    }

    // 스레드별로 독립적인 상태를 설정하는 메서드
    public void setCustomState(String state) {
        this.customState = state;
    }

    // 스레드별로 독립적인 상태를 사용하는 메서드
    public void performActionWithState() {
        System.out.println("Custom State: " + customState);
        libraryInstance.performAction();
    }
}





현재 제공된 코드는 엑세스 토큰을 발급받고, 해당 토큰을 API 요청에 사용하는 구조로 되어 있지만, 토큰이 한 시간 동안 유지되도록 관리하거나 만료 시 자동으로 갱신하는 기능은 포함되어 있지 않습니다. 만약 엑세스 토큰이 한 시간 후 만료되는 구조라면, 토큰의 만료 시간을 확인하고, 만료되었을 때 다시 발급받는 로직이 필요합니다.

이를 위해 토큰을 캐시하여 한 시간 동안 재사용하고, 만료 시간이 지나면 토큰을 자동으로 갱신하는 방식으로 구현할 수 있습니다.

1. 토큰 캐싱 및 만료 관리 로직 추가

TokenService에서 토큰 발급 후, 유효 시간(1시간) 동안 캐싱하고, 토큰이 만료되었을 때만 다시 요청하여 토큰을 발급받도록 변경합니다.

수정된 CachedTokenService:

import org.springframework.stereotype.Service;

import java.time.Instant;

@Service
public class CachedTokenService {

    private final TokenService tokenService;

    // 토큰 및 만료 시간 관리
    private String cachedToken;
    private Instant tokenExpiryTime;

    public CachedTokenService(TokenService tokenService) {
        this.tokenService = tokenService;
    }

    // 토큰을 가져오며, 만료된 경우 새로운 토큰 발급
    public String getAccessToken(String clientId, String clientSecret, String tokenUrl) {
        // 토큰이 없거나 만료되었으면 새로 발급
        if (cachedToken == null || Instant.now().isAfter(tokenExpiryTime)) {
            cachedToken = tokenService.fetchAccessToken(clientId, clientSecret, tokenUrl);
            // 토큰 발급 후 1시간 뒤에 만료 설정
            tokenExpiryTime = Instant.now().plusSeconds(3600);  // 1시간 = 3600초
        }
        return cachedToken;
    }
}

2. RestTemplateConfig에서 캐싱된 토큰 사용

RestTemplateConfig는 CachedTokenService를 사용하여 캐싱된 토큰을 가져오고, 토큰이 만료되었을 경우 새로운 토큰을 발급받아 RestTemplate을 리턴하는 방식으로 변경합니다.

수정된 RestTemplateConfig:

import org.springframework.boot.web.client.RestTemplateBuilder;
import org.springframework.context.annotation.Bean;
import org.springframework.http.HttpHeaders;
import org.springframework.http.client.ClientHttpRequestInterceptor;
import org.springframework.stereotype.Component;
import org.springframework.web.client.RestTemplate;

@Component
public class RestTemplateConfig {

    private final CachedTokenService cachedTokenService;

    public RestTemplateConfig(CachedTokenService cachedTokenService) {
        this.cachedTokenService = cachedTokenService;
    }

    // 동적으로 clientId, tokenUrl에 맞는 RestTemplate 리턴
    public RestTemplate createRestTemplate(String clientId, String clientSecret, String tokenUrl) {
        String accessToken = cachedTokenService.getAccessToken(clientId, clientSecret, tokenUrl);  // 캐싱된 토큰 사용

        // 토큰을 포함하는 인터셉터 설정
        ClientHttpRequestInterceptor interceptor = (request, body, execution) -> {
            request.getHeaders().add(HttpHeaders.AUTHORIZATION, "Bearer " + accessToken);  // 토큰 추가
            return execution.execute(request, body);
        };

        // RestTemplateBuilder로 설정된 RestTemplate 반환
        return new RestTemplateBuilder()
                .additionalInterceptors(interceptor)
                .build();
    }
}

3. 서비스에서 캐싱된 토큰을 이용한 API 호출

이제 API 호출 시 RestTemplateConfig에서 캐싱된 토큰을 사용하여 요청을 보냅니다. 요청 시 토큰이 만료되었으면 자동으로 갱신되어 새로운 토큰을 사용합니다.

수정된 ApiService:

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;

@Service
public class ApiService {

    private final RestTemplateConfig restTemplateConfig;

    @Autowired
    public ApiService(RestTemplateConfig restTemplateConfig) {
        this.restTemplateConfig = restTemplateConfig;
    }

    public String callExternalApi(String clientId, String clientSecret, String tokenUrl, String apiUrl) {
        // 캐싱된 토큰을 사용하는 RestTemplate 생성
        RestTemplate restTemplate = restTemplateConfig.createRestTemplate(clientId, clientSecret, tokenUrl);

        // GET 요청을 보내고, 응답 받기
        ResponseEntity<String> response = restTemplate.getForEntity(apiUrl, String.class);

        if (response.getStatusCode().is2xxSuccessful()) {
            return response.getBody();  // 성공하면 응답 본문 반환
        } else {
            return "Failed with status: " + response.getStatusCode();
        }
    }
}

4. 동작 흐름

	1.	CachedTokenService:
	•	엑세스 토큰이 발급되면, 해당 토큰은 1시간 동안 캐시됩니다.
	•	1시간이 지나면 토큰이 만료되고, 새로운 토큰을 발급받습니다.
	2.	RestTemplateConfig:
	•	RestTemplate을 생성할 때 CachedTokenService에서 캐싱된 토큰을 가져와 Authorization 헤더에 추가합니다.
	3.	ApiService:
	•	RestTemplateConfig에서 토큰이 포함된 RestTemplate을 가져와 API 요청을 처리합니다.

결론:

	•	이 구조에서는 엑세스 토큰이 1시간 동안 유지됩니다.
	•	토큰이 만료되면 자동으로 새로운 토큰을 발급받아 API 요청에 사용합니다.
	•	이렇게 하면 1시간 이내에는 발급받은 토큰을 계속 사용하고, 그 이후에는 자동으로 갱신된 토큰을 사용하게 됩니다.

이를 통해 엑세스 토큰을 효율적으로 관리할 수 있으며, 매번 API 요청 시마다 새로운 토큰을 발급받을 필요 없이 캐싱된 토큰을 사용할 수 있습니다.







현재 제공된 코드는 한 시간 반(90분)이 지나면 새로운 엑세스 토큰을 자동으로 받아오도록 설계되어 있습니다. 그러나 에러가 발생했을 때도 토큰을 갱신할 수 있도록 추가적인 로직을 구현하는 것이 필요합니다. 일반적으로 API 서버에서 엑세스 토큰 만료 시 “401 Unauthorized”와 같은 상태 코드가 반환될 수 있습니다. 이 경우에 토큰을 재발급하고, 다시 요청을 시도하는 로직을 추가할 수 있습니다.

import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import org.springframework.http.ResponseEntity;
import org.springframework.util.LinkedMultiValueMap;
import org.springframework.util.MultiValueMap;

@Service
public class TokenService {
    
    private static final String TOKEN_URL = "https://thirdparty.com/oauth/token";

    // 엑세스 토큰을 받아오는 메소드
    public String fetchAccessToken() {
        RestTemplate restTemplate = new RestTemplate();

        // 폼 데이터 설정
        MultiValueMap<String, String> requestData = new LinkedMultiValueMap<>();
        requestData.add("grant_type", "client_credentials");
        requestData.add("client_id", "your_client_id");
        requestData.add("client_secret", "your_client_secret");

        // POST 요청으로 토큰 가져오기
        ResponseEntity<TokenResponse> response = restTemplate.postForEntity(TOKEN_URL, requestData, TokenResponse.class);
        
        return response.getBody().getAccessToken(); // 토큰을 반환
    }

    // 응답 데이터를 담을 클래스
    public static class TokenResponse {
        private String access_token;

        public String getAccessToken() {
            return access_token;
        }

        public void setAccessToken(String access_token) {
            this.access_token = access_token;
        }
    }
}









이를 위해 RestTemplate에 재시도 로직을 추가하고, 401 상태 코드가 발생했을 때 엑세스 토큰을 갱신하는 방식을 적용할 수 있습니다.

수정된 로직 (401 에러 시 토큰 갱신 및 재시도)

	1.	토큰 갱신 인터셉터 작성:
	•	요청이 실패하고 401 에러가 발생하면 토큰을 새로 받아오고, 다시 요청을 시도하는 로직을 구현합니다.
	2.	RestTemplateBuilder에 인터셉터 적용**:
	•	ClientHttpRequestInterceptor를 사용하여 재시도 로직을 추가합니다.

구현 코드:

import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpMethod;
import org.springframework.http.HttpRequest;
import org.springframework.http.client.ClientHttpRequestExecution;
import org.springframework.http.client.ClientHttpRequestInterceptor;
import org.springframework.http.client.ClientHttpResponse;
import org.springframework.stereotype.Component;
import org.springframework.web.client.RestTemplate;

import java.io.IOException;

@Component
public class RetryableTokenInterceptor implements ClientHttpRequestInterceptor {

    private final CachedTokenService cachedTokenService;

    public RetryableTokenInterceptor(CachedTokenService cachedTokenService) {
        this.cachedTokenService = cachedTokenService;
    }

    @Override
    public ClientHttpResponse intercept(HttpRequest request, byte[] body, ClientHttpRequestExecution execution) throws IOException {
        // 엑세스 토큰을 헤더에 추가
        String accessToken = cachedTokenService.getAccessToken();
        request.getHeaders().add("Authorization", "Bearer " + accessToken);

        // 요청을 실행
        ClientHttpResponse response = execution.execute(request, body);

        // 401 상태 코드인 경우 토큰 갱신 및 재시도 로직
        if (response.getStatusCode().value() == 401) {
            // 새로운 토큰 요청
            String newAccessToken = cachedTokenService.getAccessToken(true); // 강제로 토큰 갱신

            // 기존 요청에 새로운 토큰을 추가하여 다시 실행
            request.getHeaders().remove("Authorization");
            request.getHeaders().add("Authorization", "Bearer " + newAccessToken);

            // 재시도
            response = execution.execute(request, body);
        }

        return response;
    }
}

수정된 CachedTokenService 클래스 (강제 토큰 갱신 로직 포함)

import org.springframework.stereotype.Service;

import java.time.Instant;

@Service
public class CachedTokenService {

    private final TokenService tokenService;

    private Instant tokenExpiryTime;
    private String cachedToken;

    public CachedTokenService(TokenService tokenService) {
        this.tokenService = tokenService;
    }

    // 토큰 만료 시간 확인 및 갱신 (forceRenew = true면 강제 갱신)
    public String getAccessToken() {
        return getAccessToken(false);
    }

    public String getAccessToken(boolean forceRenew) {
        if (forceRenew || cachedToken == null || Instant.now().isAfter(tokenExpiryTime)) {
            cachedToken = tokenService.fetchAccessToken();
            // 토큰 발급 후 90분 동안 유효
            tokenExpiryTime = Instant.now().plusSeconds(90 * 60);
        }
        return cachedToken;
    }
}

RestTemplate 설정에 인터셉터 추가

import org.springframework.boot.web.client.RestTemplateBuilder;
import org.springframework.context.annotation.Bean;
import org.springframework.stereotype.Component;
import org.springframework.web.client.RestTemplate;

import java.time.Duration;

@Component
public class RestTemplateConfig {

    private final RetryableTokenInterceptor retryableTokenInterceptor;

    public RestTemplateConfig(RetryableTokenInterceptor retryableTokenInterceptor) {
        this.retryableTokenInterceptor = retryableTokenInterceptor;
    }

    @Bean
    public RestTemplate restTemplate(RestTemplateBuilder builder) {
        return builder
                .setConnectTimeout(Duration.ofSeconds(30))
                .setReadTimeout(Duration.ofSeconds(30))
                .additionalInterceptors(retryableTokenInterceptor)
                .build();
    }
}

설명:

	1.	RetryableTokenInterceptor: 이 인터셉터는 HTTP 요청을 보내기 전 Authorization 헤더에 엑세스 토큰을 추가하고, 서버 응답이 401 (Unauthorized) 일 경우 엑세스 토큰을 새로 발급받아 요청을 재시도하는 로직을 포함합니다.
	•	토큰 갱신 및 재시도: 요청이 401 오류를 반환하면, 새로운 토큰을 발급받고 원래 요청을 재시도합니다.
	2.	CachedTokenService:
	•	기본적으로 90분 동안 캐시된 토큰을 반환하지만, forceRenew 플래그가 true로 설정되면 강제로 새로운 토큰을 발급받습니다.
	3.	RestTemplateConfig:
	•	RestTemplate에 인터셉터를 추가하여 모든 요청이 이 인터셉터를 거치도록 설정합니다.

전체 흐름:

	1.	정상적인 요청: 엑세스 토큰이 유효한 동안에는 캐싱된 토큰을 사용하여 요청을 보냅니다.
	2.	401 오류 발생 시: 엑세스 토큰이 만료되었거나 유효하지 않은 경우, 401 상태 코드를 감지하여 새로운 토큰을 발급받고, 동일한 요청을 다시 시도합니다.
	3.	강제 토큰 갱신: CachedTokenService는 기본적으로 캐시된 토큰을 반환하지만, 401 오류가 발생하면 강제로 토큰을 갱신합니다.

이렇게 구현하면 한 시간 반 동안 유효한 토큰을 사용하며, 토큰이 만료되거나 401 오류가 발생할 때마다 새로운 토큰을 받아 다시 요청을 시도할 수 있습니다.