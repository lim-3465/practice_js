IdAnywhere와 같은 기업 인증/인가 플랫폼을 사용하는 경우, OAuth2나 SAML과 같은 프로토콜을 기반으로 동작하는지 확인해야 합니다. 대부분의 IdAnywhere 플랫폼은 OAuth2 또는 OpenID Connect(OIDC)를 지원하며, Spring Boot에서 이를 구현하려면 약간의 맞춤 설정이 필요할 수 있습니다.

아래는 IdAnywhere를 Spring Boot와 통합하여 Authorization Code Grant Flow를 구현하는 일반적인 방법입니다. 구체적인 플랫폼 세부 사항은 IdAnywhere의 공식 문서를 참고해야 합니다.

1. 확인해야 할 사항

	1.	IdAnywhere에서 제공하는 인증 방식:
	•	OAuth2 또는 OpenID Connect(OIDC)를 지원하는지 확인.
	•	Authorization Endpoint, Token Endpoint, UserInfo Endpoint 등의 URL 정보 확보.
	2.	플랫폼에서 클라이언트 애플리케이션 등록:
	•	Spring Boot 애플리케이션을 IdAnywhere에 클라이언트로 등록.
	•	클라이언트 ID와 클라이언트 비밀(Client Secret) 발급.
	•	Redirect URI 등록 (예: https://yourapp.com/login/oauth2/code/{registrationId}).
	3.	지원하는 인증 범위:
	•	OIDC의 경우 openid, profile, email 등의 Scope를 설정.

2. Spring Boot OAuth2 설정

2.1 application.yml 구성

IdAnywhere와 연동하기 위한 정보를 설정합니다.

spring:
  security:
    oauth2:
      client:
        registration:
          idanywhere:
            client-id: your-client-id
            client-secret: your-client-secret
            redirect-uri: "{baseUrl}/login/oauth2/code/idanywhere"
            authorization-grant-type: authorization_code
            scope: openid, profile, email
        provider:
          idanywhere:
            authorization-uri: https://idanywhere.example.com/oauth/authorize
            token-uri: https://idanywhere.example.com/oauth/token
            user-info-uri: https://idanywhere.example.com/oauth/userinfo
            user-name-attribute: sub

	•	authorization-uri: IdAnywhere의 Authorization Endpoint URL.
	•	token-uri: Access Token을 요청하는 Token Endpoint URL.
	•	user-info-uri: 사용자 정보를 가져오는 UserInfo Endpoint URL.
	•	user-name-attribute: 사용자 고유 식별자 필드(sub는 OpenID Connect 표준).

2.2 Spring Security 설정

Spring Security를 구성하여 OAuth2 인증과 Access Token 처리를 자동화합니다.

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.web.SecurityFilterChain;

@Configuration
public class SecurityConfig {

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
            .csrf(csrf -> csrf.disable()) // CSRF 비활성화 (RESTful API)
            .authorizeHttpRequests(auth -> auth
                .requestMatchers("/", "/login", "/error").permitAll() // 공개 경로
                .anyRequest().authenticated() // 인증 필요
            )
            .oauth2Login(oauth2 -> oauth2
                .defaultSuccessUrl("/dashboard", true) // 성공 후 리다이렉트
            );

        return http.build();
    }
}

3. Access Code → Access Token 수동 처리 (필요 시)

Spring Security의 기본 OAuth2 Client를 사용하지 않고, Access Token 처리를 수동으로 구현해야 할 수도 있습니다.

Access Token 교환 API

import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.*;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.client.RestTemplate;

import java.util.Map;

@RestController
@RequestMapping("/api/oauth")
public class OAuth2Controller {

    @Value("${spring.security.oauth2.client.registration.idanywhere.client-id}")
    private String clientId;

    @Value("${spring.security.oauth2.client.registration.idanywhere.client-secret}")
    private String clientSecret;

    @Value("${spring.security.oauth2.client.registration.idanywhere.redirect-uri}")
    private String redirectUri;

    @Value("${spring.security.oauth2.client.provider.idanywhere.token-uri}")
    private String tokenUri;

    private final RestTemplate restTemplate;

    public OAuth2Controller(RestTemplate restTemplate) {
        this.restTemplate = restTemplate;
    }

    @PostMapping("/exchange-token")
    public ResponseEntity<Map<String, Object>> exchangeToken(@RequestBody Map<String, String> request) {
        String authorizationCode = request.get("code");

        HttpHeaders headers = new HttpHeaders();
        headers.setContentType(MediaType.APPLICATION_FORM_URLENCODED);

        String body = String.format(
            "grant_type=authorization_code&code=%s&redirect_uri=%s&client_id=%s&client_secret=%s",
            authorizationCode, redirectUri, clientId, clientSecret
        );

        HttpEntity<String> httpEntity = new HttpEntity<>(body, headers);

        ResponseEntity<Map> response = restTemplate.exchange(
                tokenUri,
                HttpMethod.POST,
                httpEntity,
                Map.class
        );

        return ResponseEntity.ok(response.getBody()); // Access Token 반환
    }
}

4. 사용자 정보 요청

Access Token을 사용해 IdAnywhere에서 사용자 정보를 요청합니다.

사용자 정보 API

import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.*;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.client.RestTemplate;

import java.util.Map;

@RestController
@RequestMapping("/api/user")
public class UserInfoController {

    @Value("${spring.security.oauth2.client.provider.idanywhere.user-info-uri}")
    private String userInfoUri;

    private final RestTemplate restTemplate;

    public UserInfoController(RestTemplate restTemplate) {
        this.restTemplate = restTemplate;
    }

    @GetMapping
    public ResponseEntity<Map<String, Object>> getUserInfo(@RequestHeader("Authorization") String authorizationHeader) {
        HttpHeaders headers = new HttpHeaders();
        headers.set("Authorization", authorizationHeader);

        HttpEntity<String> httpEntity = new HttpEntity<>(headers);

        ResponseEntity<Map> response = restTemplate.exchange(
                userInfoUri,
                HttpMethod.GET,
                httpEntity,
                Map.class
        );

        return ResponseEntity.ok(response.getBody());
    }
}

5. 프론트엔드: 인증 요청 및 처리

로그인 요청

React에서 IdAnywhere의 Authorization Endpoint로 리다이렉트합니다.

export const redirectToLogin = () => {
  const clientId = "your-client-id";
  const redirectUri = encodeURIComponent("http://localhost:8080/login/oauth2/code/idanywhere");
  const authorizationUrl = `https://idanywhere.example.com/oauth/authorize?response_type=code&client_id=${clientId}&redirect_uri=${redirectUri}&scope=openid profile email`;

  window.location.href = authorizationUrl;
};

Access Code 처리

Redirect URI에서 Access Code를 추출하고 백엔드에 전달합니다.

import axios from 'axios';

export const handleOAuthCallback = async () => {
  const urlParams = new URLSearchParams(window.location.search);
  const code = urlParams.get('code');

  if (code) {
    try {
      const response = await axios.post('/api/oauth/exchange-token', { code });
      const { access_token } = response.data;

      // Access Token 저장
      localStorage.setItem('accessToken', access_token);

      // 사용자 정보 요청
      const userInfo = await axios.get('/api/user', {
        headers: {
          Authorization: `Bearer ${access_token}`,
        },
      });

      console.log(userInfo.data);
    } catch (error) {
      console.error('OAuth callback error:', error);
    }
  } else {
    console.error('Authorization code not found');
  }
};

요약

	1.	IdAnywhere 설정:
	•	클라이언트 ID, 비밀 키, Redirect URI, Endpoints 설정.
	2.	Spring Boot:
	•	Spring Security OAuth2 Client를 통해 Authorization Code Grant Flow 설정.
	•	Access Code 처리 및 Access Token 요청 구현.
	3.	프론트엔드:
	•	OAuth2 Authorization Endpoint로 리다이렉트.
	•	Access Code를 백엔드로 전달하고 Access Token 및 사용자 정보 요청.

a. Refresh Token으로 Access Token 갱신 로직 추가 요청.
b. 사용자 역할(Role) 기반 접근 제어 로직 구현 요청.

Access Token을 통해 사용자 정보를 인증하고, 이를 프론트엔드와 백엔드에서 활용하는 방법을 설명하겠습니다. 특히, Access Token을 파싱하여 사용자 이름, 이메일, 역할(role) 등의 정보를 추출하는 방법을 다루겠습니다. JWT(JSON Web Token)를 Access Token으로 사용하는 경우, 이를 통해 손쉽게 인증 및 정보를 추출할 수 있습니다.

1. Access Token을 Certificate로 분해하여 사용자 정보 추출 (백엔드)

Access Token이 JWT 형식이라면, 이를 디코딩하여 사용자 정보를 추출할 수 있습니다. Spring Boot에서 JWT를 파싱하려면 java-jwt 라이브러리를 사용하여 간단하게 구현할 수 있습니다.

1.1 JWT 토큰을 파싱하여 사용자 정보 추출

import com.auth0.jwt.JWT;
import com.auth0.jwt.algorithms.Algorithm;
import com.auth0.jwt.interfaces.DecodedJWT;
import org.springframework.stereotype.Service;
import java.util.Map;

@Service
public class TokenParserService {

    private final String SECRET_KEY = "your-secret-key"; // 실제 키로 대체해야 함

    public Map<String, String> parseToken(String accessToken) {
        DecodedJWT jwt = JWT.require(Algorithm.HMAC256(SECRET_KEY))
                            .build()
                            .verify(accessToken);

        String username = jwt.getClaim("name").asString();
        String email = jwt.getClaim("email").asString();
        String role = jwt.getClaim("role").asString();

        return Map.of(
            "name", username,
            "email", email,
            "role", role
        );
    }
}

위의 코드에서는 java-jwt 라이브러리를 사용하여 Access Token을 디코딩합니다. JWT가 검증되면 name, email, role 등의 클레임 정보를 추출할 수 있습니다.

1.2 TokenParserService를 통해 사용자 정보 활용

이제 TokenParserService를 사용해 파싱된 사용자 정보를 얻고, 이 정보를 API 응답으로 제공하거나 필요한 인증 및 인가 로직에 사용할 수 있습니다.

import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestHeader;
import org.springframework.web.bind.annotation.RestController;
import java.util.Map;

@RestController
public class UserInfoController {

    private final TokenParserService tokenParserService;

    public UserInfoController(TokenParserService tokenParserService) {
        this.tokenParserService = tokenParserService;
    }

    @GetMapping("/api/userinfo")
    public Map<String, String> getUserInfo(@RequestHeader("Authorization") String token) {
        String accessToken = token.replace("Bearer ", "");
        return tokenParserService.parseToken(accessToken);
    }
}

이제 /api/userinfo 엔드포인트는 Access Token을 받아 사용자 이름, 이메일, 역할 정보를 클라이언트에 반환합니다.

2. 프론트엔드에서 Access Token 로그인 및 사용자 정보 요청 (React)

프론트엔드에서는 백엔드에서 발급된 Access Token을 localStorage에 저장하여 인증에 사용하고, 필요한 경우 /api/userinfo 엔드포인트를 통해 사용자 정보를 요청합니다.

2.1 Access Token 발급 및 저장

// authService.js
import axios from 'axios';

export const loginWithToken = async (username, password) => {
  try {
    const response = await axios.post('/api/login', { username, password });
    const accessToken = response.data.accessToken;
    localStorage.setItem('accessToken', accessToken);
    return accessToken;
  } catch (error) {
    console.error('Login failed:', error);
    throw error;
  }
};

위의 코드에서 /api/login 엔드포인트를 통해 사용자 인증을 요청하고, 응답으로 받은 Access Token을 localStorage에 저장합니다.

2.2 Access Token을 이용해 사용자 정보 요청

// userService.js
import axios from 'axios';

export const fetchUserInfo = async () => {
  const token = localStorage.getItem('accessToken');
  try {
    const response = await axios.get('/api/userinfo', {
      headers: {
        Authorization: `Bearer ${token}`,
      },
    });
    return response.data;
  } catch (error) {
    console.error('Error fetching user info:', error);
    throw error;
  }
};

이제 fetchUserInfo 함수는 Access Token을 Authorization 헤더에 포함하여 /api/userinfo 엔드포인트에 요청을 보내 사용자 정보를 가져옵니다.

2.3 React 컴포넌트에서 사용자 정보 렌더링

React 컴포넌트에서 fetchUserInfo 함수를 호출하여 사용자 정보를 받아와 표시할 수 있습니다.

import React, { useEffect, useState } from 'react';
import { fetchUserInfo } from './userService';

const UserProfile = () => {
  const [userInfo, setUserInfo] = useState(null);

  useEffect(() => {
    const getUserInfo = async () => {
      try {
        const data = await fetchUserInfo();
        setUserInfo(data);
      } catch (error) {
        console.error('Failed to load user info', error);
      }
    };
    getUserInfo();
  }, []);

  if (!userInfo) {
    return <div>Loading...</div>;
  }

  return (
    <div>
      <h1>User Profile</h1>
      <p>Name: {userInfo.name}</p>
      <p>Email: {userInfo.email}</p>
      <p>Role: {userInfo.role}</p>
    </div>
  );
};

export default UserProfile;

이 컴포넌트는 useEffect 훅을 사용해 fetchUserInfo를 호출하여 사용자 정보를 가져와 상태로 관리하고, 렌더링 시 userInfo의 각 필드를 화면에 표시합니다.

요약

	•	백엔드: RestTemplate을 사용해 Access Token을 발급받아 헤더에 추가하여 요청하고, JWT를 파싱하여 사용자 정보를 추출.
	•	프론트엔드: Access Token을 localStorage에 저장하여 인증에 사용하고, 백엔드의 /api/userinfo 엔드포인트를 통해 사용자 정보를 요청하고 표시.

a. Access Token 만료 시 자동 재발급 기능 추가
b. 프론트엔드에서 사용자 정보의 보안을 위한 추가 전략





사용자가 컨트롤러를 호출할 때 날짜, 시간, 사용자 ID, 호출한 API 주소 등을 데이터베이스에 기록하려면, AOP(Aspect-Oriented Programming)를 사용하여 모든 API 호출에 대한 로깅을 중앙 집중화할 수 있습니다. 이를 통해 코드 중복을 줄이고, 필요한 모든 정보가 데이터베이스에 기록되도록 할 수 있습니다.

### 1. 데이터베이스 테이블 설계

먼저, 로그를 기록할 데이터베이스 테이블을 설계해야 합니다. 예를 들어, 다음과 같은 테이블을 생성할 수 있습니다.

#### SQL 스크립트

```sql
CREATE TABLE api_call_logs (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    user_id VARCHAR(255),
    api_url VARCHAR(255),
    http_method VARCHAR(10),
    timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    request_data TEXT
);
```

이 테이블은 API 호출의 ID, 사용자 ID, 호출한 API의 URL, HTTP 메서드, 호출 시간, 그리고 요청 데이터를 저장합니다.

### 2. AOP를 사용한 로깅 구현

이제 Spring AOP를 사용하여 모든 컨트롤러 호출을 가로채고, 필요한 정보를 데이터베이스에 기록하는 로직을 작성하겠습니다.

#### 2.1. 로깅 서비스 작성

먼저, API 호출 정보를 데이터베이스에 저장하는 `LoggingService`를 작성합니다.

```java
import org.springframework.stereotype.Service;
import org.springframework.beans.factory.annotation.Autowired;

@Service
public class LoggingService {

    private final ApiCallLogRepository apiCallLogRepository;

    @Autowired
    public LoggingService(ApiCallLogRepository apiCallLogRepository) {
        this.apiCallLogRepository = apiCallLogRepository;
    }

    public void logApiCall(String userId, String apiUrl, String httpMethod, String requestData) {
        ApiCallLog log = new ApiCallLog(userId, apiUrl, httpMethod, requestData);
        apiCallLogRepository.save(log);
    }
}
```

#### 2.2. AOP 애스펙트 작성

이제 AOP를 사용하여 모든 컨트롤러 호출을 가로채는 `LoggingAspect`를 작성합니다.

```java
import org.aspectj.lang.JoinPoint;
import org.aspectj.lang.annotation.AfterReturning;
import org.aspectj.lang.annotation.Aspect;
import org.springframework.stereotype.Component;
import javax.servlet.http.HttpServletRequest;
import org.aspectj.lang.annotation.Before;
import org.aspectj.lang.annotation.Pointcut;

@Component
@Aspect
public class LoggingAspect {

    private final LoggingService loggingService;
    private final HttpServletRequest request;

    public LoggingAspect(LoggingService loggingService, HttpServletRequest request) {
        this.loggingService = loggingService;
        this.request = request;
    }

    @Pointcut("within(@org.springframework.web.bind.annotation.RestController *)")
    public void controllerMethods() {}

    @AfterReturning("controllerMethods()")
    public void logAfter(JoinPoint joinPoint) {
        String userId = request.getHeader("User-ID");  // 헤더에서 사용자 ID 추출, 다른 방법으로도 가져올 수 있음
        String apiUrl = request.getRequestURI();  // 호출된 API URL
        String httpMethod = request.getMethod();  // HTTP 메서드(GET, POST 등)
        String requestData = request.getQueryString();  // 요청 파라미터들

        loggingService.logApiCall(userId, apiUrl, httpMethod, requestData);
    }
}
```

위 코드에서:

- `@Pointcut("within(@org.springframework.web.bind.annotation.RestController *)")`: 모든 `@RestController` 클래스에 정의된 메서드들이 이 포인트컷에 포함됩니다.
- `@AfterReturning("controllerMethods()")`: 컨트롤러 메서드가 정상적으로 실행된 후에 로깅이 수행됩니다.
- `HttpServletRequest`: Spring이 제공하는 HTTP 요청 객체로, 이를 통해 API URL, HTTP 메서드, 요청 데이터 등을 추출할 수 있습니다.
- `logApiCall`: `LoggingService`를 사용해 로그를 데이터베이스에 저장합니다.

#### 2.3. API 호출 로그 엔티티 및 레포지토리 작성

로그 데이터를 저장할 엔티티와 레포지토리를 작성합니다.

##### 엔티티 클래스

```java
import javax.persistence.*;

@Entity
public class ApiCallLog {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String userId;
    private String apiUrl;
    private String httpMethod;
    private String requestData;

    @Column(nullable = false, updatable = false)
    private Timestamp timestamp;

    public ApiCallLog(String userId, String apiUrl, String httpMethod, String requestData) {
        this.userId = userId;
        this.apiUrl = apiUrl;
        this.httpMethod = httpMethod;
        this.requestData = requestData;
        this.timestamp = new Timestamp(System.currentTimeMillis());
    }

    // 기본 생성자, 게터 및 세터 생략
}
```

##### 레포지토리 인터페이스

```java
import org.springframework.data.jpa.repository.JpaRepository;

public interface ApiCallLogRepository extends JpaRepository<ApiCallLog, Long> {
}
```

### 3. 전체 흐름 요약

1. **사용자가 API 호출**: 사용자가 컨트롤러에 정의된 API를 호출합니다.
2. **AOP 애스펙트가 호출을 가로챔**: AOP가 이 호출을 가로채어 필요한 정보를 추출합니다.
3. **로그 저장**: `LoggingService`를 통해 추출한 정보를 데이터베이스에 저장합니다.
4. **컨트롤러 정상 실행**: AOP 애스펙트가 실행된 후, 컨트롤러 로직이 정상적으로 실행됩니다.

### 결론

이 방식으로, 사용자가 API를 호출할 때마다 관련 정보를 자동으로 데이터베이스에 기록할 수 있습니다. AOP를 사용하면 이러한 로깅 로직을 개별 컨트롤러 메서드에 반복적으로 작성할 필요가 없으므로 코드의 간결성과 유지보수성을 높일 수 있습니다. 또한, 로깅 이외의 횡단 관심사에도 AOP를 적용할 수 있습니다.